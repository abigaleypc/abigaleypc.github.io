<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法 | 面试总结]]></title>
    <url>%2F2018%2F07%2F02%2Finterview-arithmetic%2F</url>
    <content type="text"><![CDATA[数据结构栈栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。想象一下，我们平常在饭馆见到的一摞盘子就是现实世界常见的栈的例子，只能从最上面取盘子，盘子洗干净后，也只能放在最上面。栈被称为一种后入先出的数据结构。是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快。 使用条件： 只要数据的保存满足后入先出或先进后出的原理，都优先考虑使用栈 123456789101112131415161718192021222324252627function Stack() &#123; var items = []; this.push = function(element)&#123;//添加一个（或几个）新元素到栈顶 items.push(element); &#125;; this.pop = function()&#123;//移除栈顶的元素，同时返回被移除元素 return items.pop(); &#125;; this.peek = function()&#123;//返回栈顶的元素，但并不对栈做任何修改 return items[items.length-1]; &#125;; this.isEmpty = function()&#123;//如果栈内没有任何元素就返回true，否则返回false return items.length == 0; &#125;; this.size = function()&#123;//返回栈里的元素个数 return items.length; &#125;; this.clear = function()&#123;//移除栈里的所有元素 items = []; &#125;; this.print = function()&#123;//打印 console.log(items.toString()); &#125;; this.toString = function()&#123; return items.toString(); &#125;;&#125; 队列队列也是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。想象一下，我们在银行排队，排在最前面的人第一个办理业务，而后面来的人只能排在队伍的后面，直到轮到他们为止。 使用条件： 只要数据的保存满足先进先出、后入后出的原理，都优先考虑使用队列常见应用场景： 队列主要用在和时间有关的地方，特别是操作系统中，队列是实现多任务的重要机制消息机制可以通过队列来实现，进程调度也是使用队列来实现 123456789101112131415161718192021222324function Queue() &#123; var items = []; this.enqueue = function(element)&#123;//向队列尾部添加一个（或是多个）元素 items.push(element); &#125;; this.dequeue = function()&#123;//移除队列的第一个元素，并返回被移除的元素 return items.shift(); &#125;; this.front = function()&#123;//返回队列的第一个元素——最先被添加的,也将是最先被移除的元素。队列不做任何变动。（不移除元素，只返回元素信息。与stack的peek方法类似） return items[0]; &#125;; this.isEmpty = function()&#123;//如果队列内没有任何元素就返回true，否则返回false return items.length == 0; &#125;; this.clear = function()&#123;//移除队列里的所有元素 items = []; &#125;; this.size = function()&#123;//返回队列里的元素个数 return items.length; &#125;; this.print = function()&#123;//打印 console.log(items.toString()); &#125;; &#125; 链表链表也是一种列表，为什么需要出现链表，JavaScript中数组的主要问题时，它们被实现成了对象，与其他语言（比如C++和Java）的数组相对，效率很低。如果你发现数组在实际使用时很慢，就可以考虑使用链表来代替它。 使用条件： 链表几乎可以用在任何可以使用一维数组的情况中。如果需要随机访问，数组仍然是更好的选择。 二叉树和二叉查找树 树是计算机科学中经常用到的一种数据结构。 树是一种非线性的数据结构，以分层的方式存储数据。 二叉树每个节点的子节点不允许超过两个。一个父节点的两个子节点分别称为左节点和右节点，通过将子节点的个数限定为2，可以写出高效的程序在树中插入、查找和删除数据。 二叉查找树（BST）是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。 二叉查找树实现方法123456789101112131415161718192021222324252627282930313233343536373839404142function Node(data, left, right) &#123; // 创建节点 this.data = data; this.left = left; this.right = right; this.show = show&#125;function show () &#123; // 显示树的数据 return this.data&#125;function BST () &#123; // 二叉查找树类 this.root = null; this.insert = insert; this.inOrder = inOrder; // inOrder是遍历BST的方式&#125;function insert (data) &#123; // 向树中插入数据 var n = new Node(data, null, null) if (this.root == null) &#123; this.root = n; &#125; else &#123; var current = this.root; var parent; while (true) &#123; parent = current if (data &lt; current.data) &#123; current = current.left; if (current == null) &#123; parent.left = n; break; &#125; &#125; else &#123; current = current.right; if (current == null) &#123; parent.right = n; break; &#125; &#125; &#125; &#125;&#125; 时间复杂度一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记为 T(n) = O(f(n)) ，它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。这里需要重点理解这个增长率。 举个例子，看下面3个代码： 1、{++x;} 2、for(i = 1; i &lt;= n; i++) { ++x; } 3、for(j = 1; j &lt;= n; j++) for(j = 1; j &lt;= n; j++) { ++x; } 上述含有 ++x 操作的语句的频度分别为1 、n 、n^2， 假设问题的规模扩大了n倍，3个代码的增长率分别是1 、n 、n^2 它们的时间复杂度分别为O(1)、O(n )、O(n^2) 二分查找 二分查找的时间复杂度为O(logn) 规则 定义最小索引和最大索引 计算出中间索引 拿中间的索引和要查找元素的索引进行比较 相等:就返回当前的中间索引 不相等: 如果大了:在左边查找,max = min - 1 如果小了:在右边查找,min = min + 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 二分查找，递归实现。 * @param target 目标数字 * @param arr 原数组 * @param start 开始的地方 * @param end 结束的地方 * @returns &#123;*&#125; */function binarySearch(target,arr,start,end) &#123; var start = start || 0; var end = end || arr.length-1; var mid = parseInt(start+(end-start)/2); if(target==arr[mid])&#123; return mid; &#125;else if(target&gt;arr[mid])&#123; return binarySearch(target,arr,mid+1,end); &#125;else&#123; return binarySearch(target,arr,start,mid-1); &#125; return -1;&#125;/** * 有序的二分查找，返回-1或存在的数组下标。不使用递归实现。 * @param target * @param arr * @returns &#123;*&#125; */function binarySearch(target,arr) &#123; var start = 0; var end = arr.length-1; while (start&lt;=end)&#123; var mid = parseInt(start+(end-start)/2); if(target==arr[mid])&#123; return mid; &#125;else if(target&gt;arr[mid])&#123; start = mid+1; &#125;else&#123; end = mid-1; &#125; &#125; return -1;&#125; 排序1234567let len = array.lengthswap = (array, index1, index2) =&gt; &#123; let temp = array[index2] array[index2] = array[index1] array[index1] = temp&#125; 冒泡 从第一个数字开始，依次往后对比，直到最后一位，当该数字大于/小于查找位置上数字时，交换数字 重新一轮开始时，对比直到倒数第二位 1234567for (let i = 0; i &lt; len; i++) &#123; for (let j = 0; j &lt; len - i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; swap(array, j, j + 1) &#125; &#125;&#125; 选择排序 与冒泡相似 从第一位开始，依次对比找到最小那一位，存下下标，与第一位做交换 从第二位开始，再次找最小那一位 12345678910111213let minfor (let i = 0; i &lt; len; i++) &#123; min = i for (let j = i + 1; j &lt; len; j++) &#123; if (array[min] &gt; array[j]) &#123; min = j &#125; &#125; if (min != i) &#123; swap(array, i, min) &#125;&#125; 插入排序 将组分成“已排序”和“未排序” 从第一位开始，依次从“未排序”获取一位，再对“已排序”列表进行排序 123456789101112131415161718192021// 方案一for (let i = 0;i &lt; len; i++) &#123; for (let j = i;j &gt; 0;j--) &#123; if (array[j] &gt; array[j - 1]) &#123; swap(array, j, j - 1) &#125; &#125;&#125;// 方案二：以下方法可以减少交换次数for (let i = 0; i &lt; len; i++) &#123; let value = array[i] for (let j = i; j &gt;= 0; j--) &#123; if (array[j - 1] &gt; value) &#123; array[j] = array[j - 1] &#125; else &#123; array[j] = value break &#125; &#125;&#125; 归并排序/分治法123456789101112131415161718192021222324252627282930function mergeSort(arr) &#123; if (arr.length &lt;= 1) return arr; let middle = parseInt(arr.length / 2) let left = arr.slice(0, middle) let right = arr.slice(middle) if (!left || !right) &#123; return false; &#125; return merge(mergeSort(left), mergeSort(right))&#125;function merge(left, right) &#123; let result = [] while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while (left.length) &#123; result.push(left.shift()) &#125; while (right.length) &#123; result.push(right.shift()) &#125; return result&#125; 参考：JavaScript排序算法（二）——归并排序 快速排序取中间值，然后不断比较左右两边的数组 123456789101112131415var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var index = parseInt(arr.length / 2); var pivot = arr[index]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right)); &#125;;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人开源项目 | 面试总结]]></title>
    <url>%2F2018%2F07%2F02%2Finterview-project%2F</url>
    <content type="text"><![CDATA[介绍项目 豆瓣FM桌面版：https://github.com/abigaleypc/musicer 该项目主要是一款电豆瓣FM的桌面应用，我将豆瓣FMweb端 (http://douban.fm/) 的功能移植到桌面应用中。该应用使用跨平台框架可兼容Mac和Windows。 架构思路：前后端的架构和选型分析；前后端分离与接入层接口封装，前端与接入层规范对接；数据状态管理；登录态保持与抓包过程。 功能模块：主要模块有当前频道，歌词滚动，微信分享，切换频道，点赞，删除歌词，用户登录等功能。前端主要用了react去组件化各个模块，包括组件之间的数据流通。 当前歌曲，歌词滚动，微信分享这几个模块都需要知道当前歌曲的ID，我会将当前歌曲的一些必要信息存在一个state里面比如songID。切换歌曲模块主要触发songID更改的一个action,当歌曲被更改时，刚上面提到的内容接收到新的状态也会被更新。其中歌词滚动这一模块需要不断监听当前时间并做滚动处理，我的做法类似节流的方式，每隔0.3s就做一个更新，主要是从歌词一开始设定当前时间为0，豆瓣FM获取到的歌曲它是有带每句歌词对应的时间，我是将我们设定的时间不停累加，插在处于对应歌词之间的地方，如果0.3s之后还在当前两句歌词范围内就不滚动。 面试过程中提到歌词滚动的优化，可在每获取一句歌词时再读取一次下一句歌词的时间，再将settimeout的时间戳设为两句歌词的间隔时间。 点赞和删除歌曲会检测当前登录态，如果当前未登录，就会直接跳转到登录界面。如有已经登录，就会带上登录态去做一些请求 登录态，在调用豆瓣FM的所有接口我都没在前端直接调用，而是做了一个NODE的接入层，获取或者修改信息都是通过node接入层再到了豆瓣FM官网。 状态管理豆瓣FM桌面版采用redux做状态管理。Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 三个原则 单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的惟一改变 state 的方法就是触发 action:action 是一个用于描述已发生事件的普通对象。视图和网络请求都不能直接修改 state，它们只能表达想要修改的意图。所有的修改都被集中化处理，且严格按照一个接一个的顺序执行,因此不用担心 race condition 的出现。 Action 是普通对象,可以被日志打印,后期调试或测试时回放出来。 使用纯函数reducers来执行修改为了描述 action 如何改变 state tree ，需要编写 reducers,reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始可以只有一个 reducer，随着应用变大，可以拆成多个小的 reducers，分别独立地操作 state tree 的不同部分,甚至编写可复用的 reducer 来处理一些通用任务，如分页器。 数据流 store:是保存所有数据的地方，你可以把它看成一个容器。 state:Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。 action: State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。 reducer: Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 参考： 阮一峰redux教程 Redux分析redux可以让构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用）简单清量（只有2kB）且没有任何依赖由 Flux 演变而来，但受 Elm 的启发，避开了 Flux 的复杂性做复杂应用和庞大系统时优秀的扩展能力。可以用 action 追溯应用的每一次修改 (因此才有强大的开发工具。如录制用户会话并回放所有 action 来重现它)单一的state tree:让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。调试也变得非常容易 需要Redux 多交互、多数据源 可以用 action 追溯应用的每一次修改 在React中我们要传递状态特别麻烦，特别是遇到非父子组件的。但redux提供给我们的是全局的状态，所有状态集合store,通知作用的action和执行官reducer。这样很好地减少数据耦合，我们可以站在一个地方观览所有数据。 redux把流程规范了，统一渲染根节点虽然对代码管理上规范了一些,只要有需要显示数据的组件，当相关数据更新时都会自动进行更新 抛弃Redux 操作多个数据流，包括异步流时较繁琐 一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 每次添加新状态都需要在store,action,reducer添加新行为，这让代码看起来非常冗余，似乎写了特别多重复性代码，如果追求代码简洁，redux会让你泪奔~~o(&gt;_&lt;)o ~~ 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层（View）只从单一来源获取数据 项目中如何使用redux? React和Redux分工React-Redux将所有组件分为了UI组件和容器组件。UI组件不带任何逻辑，只负责渲染，所有的数据都通过this.props提供。（由React负责）容器组件负责数据管理和业务逻辑处理。（由Redux负责） Providerreact-redux提供了Provider组件，用于保存store给子组件中connect使用。将它包裹在根组件的最外层，它会将store传递给容器组件。 connect()connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])的作用是生成容器组件，容器组件将UI组件包装了起来，所有的数据都存放在容器组件上。 mapStateToProps(state)该方法的作用是:组件将监听store的任何变化，返回需要传递给子组件的state，返回的值将作为属性绑定在容器组件上。之后UI组件就可以通过this.props去读取数据了。 mapDispatchToProps(dispatch)该方法的作用是：将逻辑处理事件传递给子组件，返回一个dispatchProps对象，该对象是action和dispatch的一个组合。返回的对象将被绑定在UI组件上，返回结果类似如下结构： 123&#123; addItem: (text) =&gt; dispatch(action)&#125; mergeProps(): [mergeProps(stateProps, dispatchProps, ownProps): props] (Function), 如果指定了这个参数，mapStateToProps()与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。 参考： React-Redux学习 登录态 与 接入层 用户未登录的情况下 输入用户名密码 接入层模仿浏览器(User-Agent)访问豆瓣FM,并拦截它的重定向，模仿浏览器再次访问多个重定向的地址,获取到证明个人身份的多个值和token,加密写入本地文件夹。返回用户登录成功(本地存下token+用户名 + 个人信息) 第二次进入时，访问后端判断token是否失效，未失效就采用前端的个人信息失效了或者无token 则登录态为未登录 参考：搭建音乐播放器桌面应用–前端篇 , 扮演服务层角色 – NodeJs 采用Electron 跨平台: 兼容Mac, Windows 和 Linux 浏览器兼容: PC端的前端攻城狮经常需要考虑浏览器的兼容性，而当我们把呈现在页面上的内容转移到应用上时，我们可以直接根据Chrome浏览器编程。 快速上手: 这可以直接省去大量学习成本，只要搭建好基础框架，就可以像写页面一样去写应用。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端框架 | 面试总结]]></title>
    <url>%2F2018%2F06%2F28%2Finterview-FE-frame%2F</url>
    <content type="text"><![CDATA[AngularAngular是怎么实现双向绑定的？脏检查机制： Angular 在解析视图模板时, 会找出其中的数据绑定, 以及对应的更新DOM的方式 然后通过 $scope.$watch 将这一绑定注册到当前 $scope 上下文的更新响应操作里。 $digest 每一个循环里会从根作用域开始遍历所有的 $scope 注册的 $watch 响应操作 当发现值有变化时，更新DOM数据。 这其中是通过一个dirty为true或false去更新数据。 参考: Angular沉思录（一）数据绑定 angular的路由是怎么实现的？通过更新hash值 Vue双向绑定Vue是怎么实现双向绑定的？ 通过Object.defineProperty()进行数据劫持，设置各个属性的setter，getter，在数据变动时触发相应的监听回调。 具体实现： 数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 / 它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 mvvm入口函数，整合以上三者 参考: 剖析Vue实现原理 - 如何实现双向绑定mvvm 具体实现 实现数据的双向绑定，首先要对数据进行劫持监听， 我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析 将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 因此接下去我们执行以下3个步骤，实现数据的双向绑定： 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者Watcher，为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 实现一个解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 参考：vue的双向绑定原理及实现 双向绑定图解 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed 生命周期图解 参考：详解vue生命周期 Vue的路由是怎么实现的？ 通过更新hash值 采用H5的history api history.pushState() history.replaceState() history.back(); history.go() 为什么采用VUE 使用 Virtual DOM 提供了响应式（Reactive）和组件化（Composable）的视图组件。 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染 Vue - template1234567891011121314151617181920212223242526272829303132333435363738394041var vm = new Vue(&#123; // 选项 el: "#app", data: &#123; name: "", age: 10 &#125;, watch: &#123; a: function(val, oldVal) &#123; console.log("new: %s, old: %s", val, oldVal); &#125;, // 方法名 b: "someMethod", // 深度 watcher c: &#123; handler: function(val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: function(val, oldVal) &#123; /* ... */ &#125;, immediate: true &#125;, e: [ function handle1(val, oldVal) &#123; /* ... */ &#125;, function handle2(val, oldVal) &#123; /* ... */ &#125; ], // watch vm.e.f's value: &#123;g: 5&#125; "e.f": function(val, oldVal) &#123; /* ... */ &#125; &#125;&#125;); 12345&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 `foo` 不会更新！ --&gt; &lt;button v-on:click="foo = 'baz'"&gt;Change it&lt;/button&gt;&lt;/div&gt; or 12345678910111213141516171819&lt;template&gt; &lt;div class="messgae"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return &#123; msg:'Hello from vue-loader' &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;.message&#123; color:red; font-size:36px; font-weight:blod;&#125;&lt;/style&gt; React性能问题性能问题： 关于组件重新渲染的问题： 没有导致state的值发生变化的setState是否会导致重渲染？ 组件的state没有变化，并且从父组件接受的props也没有变化，那它就还可能重渲染吗？ 以上两个问题答案分别为【是】和【可能】。解决以上的问题需要shouldComponentUpdate(nextProps,nextState)配合。shouldComponentUpdate只有返回true,componentWillUpdate render componentDidUpdate都会被调用，则组件会被重新渲染。返回false则不会重新渲染 第一个问题：当本组件调用了setState时输入空参数，或者不改变state，shouldComponentUpdate会被调用。所以组件会被重新渲染，这时可以做如下改进 123456//在render函数调用前判断：如果前后state中Number不变，通过return false阻止render调用shouldComponentUpdate(nextProps,nextState)&#123; if(nextState.Number == this.state.Number)&#123; return false &#125;&#125; 第二个问题：当父组件之下有多个子组件，父组件更改了state,会影响其中一个子组件的props，本来只有该子组件被重新渲染，但发现多个子组件都被重新渲染了，这时同样需要在shouldComponentUpdate做一个调整，当props更新时shouldComponentUpdate返回true,否则返回false 123456 shouldComponentUpdate(nextProps,nextState)&#123; if(nextProps.number == this.props.number)&#123; return false &#125; return true&#125; nextProps.number == this.props.number不能写成nextProps == this.props，它总返回false因为它们是堆中内存不同的两个对象。 但当组件是对象 数组时，只用等于号判断是不合理的，因为他们存的是引用地址，可以采用深拷贝去更新每一次变化 比如将 123this.setState(&#123; number: [number[0],2,number[2])&#125;) 改为 1234let number = number.slice(0) // 即深拷贝到新的地址this.setState(&#123; number&#125;) 关于setState调用 setState 之后发生了什么？ 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。 经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 参考： React官方setState 调和过程：setState通过引发一次组件的更新过程来引发重新绘制；setState调用引起的React的更新生命周期函数4个函数（比修改prop引发的生命周期少一个componentWillReceiveProps函数），这4个函数依次被调用。 shouldComponentUpdate 返回true时才会做以下操作 componentWillUpdate render 这一步this.state才得到更新 componentDidUpdate setState不会立刻改变React组件中state的值；不会。修改this.state.number 会引起状态改变 但不会引起UI的更新。所以setState用来调用做UI更新 多次setState函数调用产生的效果会合并。因为React会将多个this.setState产生的修改放在一个队列里，缓一缓，攒在一起，觉得差不多了再引发一次更新过程。 关于 setState() 这里有三件事情需要知道 不要直接更新状态 如 this.state.number = 1;该方法没调用setState就不会走生命周期 状态更新可能是异步的；所以以下代码错误 123this.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 正确的方式 123this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); 状态更新合并: 调用setState时，虽然参数只有一个值，但它会与其他state先合并 setState可以接受函数为参数吗？有什么作用？ 123this.setState((prevState, props) =&gt; &#123; return &#123;counter: prevState.counter + props.step&#125;;&#125;); 函数接收到的prevState 和 props保证都是最新的。比如我们多次更改state时有时可能异步的问题，重叠忽略了一些 比如this.setState({number:this.state.number+1})连续调用三次，但三次this.state.number的值一样时，有可能最后并不是加了三次 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成 什么时候不能调用setState componentWillUpdate(): 我也不知道这个声明周期函数的意义在哪里，在这个函数内你不能调用setState改变组件状态render() 什么时候调用setState不会再次调用render componentWillReceiveProps(nextProps): 在这里你可以拿到即将改变的状态，可以在这一步中通过setState方法设置state ，这一步setState不会让重新render() 生命周期描述一下React组件的各个生命周期函数吗/组件的生命周期有哪些组件的声明周期有三种阶段 初始化阶段（Mounting） 更新阶段（Updating） 析构阶段（Unmounting） 组件的初始化阶段 constructor(): 用于绑定事件以及初始化state（可以通过”fork”props的方式给state赋值） componentWillMount(): 只会在服务端渲染时被调用，你可以在这里同步操作state。由于这个方法始终只执行一次，所以如果在这里定义了setState方法之后，页面永远都只会在加载前更新一次。 render(): 这个函数是用来渲染DOM没有错。但它只能用来渲染DOM，请保证它的纯粹性。如果有操作DOM或者和浏览器打交道的一系列操作，请在下一步骤componentDidMount中进行 componentDidMount(): 如果你有第三方操作DOM的类库需要初始化（类似于jQuery，Bootstrap的一些组件）操作DOM、或者请求异步数据，都应该放在这个步骤中做 组件更新阶段 componentWillReceiveProps(nextProps): 在这里你可以拿到即将改变的状态，可以在这一步中通过setState方法设置state 。这里拿到的this.props还是就的props. shouldComponentUpdate(nextProps, nextState): 这一步骤非常重要，它的返回值决定了接下来的生命周期函数是否会被调用，默认返回true，即都会被调用；你也可以重写这个函数使它返回false。 componentWillUpdate(): 我也不知道这个声明周期函数的意义在哪里，在这个函数内你不能调用setState改变组件状态，否则会立即触发另一轮的渲染并且又再一次调用componentWillUpdate，陷入无限循环中。 render() componentDidUpdate(): 和componentDidMount类似，在这里执行DOM操作以及发起网络请求 组件析构阶段 componentWillUnmount(): 主要用于执行一些清理工作，比如取消网络请求，清楚多余的DOM元素等。清除componentDidMount 或 componentDidUpdate中的任务。 参考：各个函数的描述 生命周期图解 渲染机制 要点：合并，diff算法 ， 生命周期调用过程 更新渲染过程 setState() 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 调和过程中采用Diff算法，不同节点类型的比较 ，分两种情况： 节点类型不同： 直接删除旧的节点，再新建新的节点 节点类型相同，属性不同： 对比属性，只改变变化了的节点属性 构建 React 元素树并且着手重新渲染整个UI界面 shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 参考：React 渲染机制解析,深入浅出React（四）：虚拟DOM Diff算法解析 其他在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？ 在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 12345678function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125; 使用类就允许我们使用其它特性，例如局部状态、生命周期钩子 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; React 中 Element 与 Component 的区别是？ 简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。 React 中的 refs 作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。 允许您直接访问DOM元素或组件实例 1&lt;Input ref = &#123;input =&gt; this.Input=input&#125;&gt; Controlled Component 与 Uncontrolled Component 之间的区别是什么？React 的核心组成之一就是能够维持内部状态的自治组件，不过当我们引入原生的HTML表单元素时（input,select,textarea 等），我们是否应该将所有的数据托管到 React 组件中还是将其仍然保留在 DOM 元素中呢？这个问题的答案就是受控组件与非受控组件的定义分割。受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。譬如下面这段代码中username变量值并没有存放到DOM元素中，而是存放在组件状态数据中。任何时候我们需要改变username变量值时，我们应当调用setState函数进行修改。 竟然非受控组件看上去更好实现，我们可以直接从 DOM 中抓取数据，而不需要添加额外的代码。不过实际开发中我们并不提倡使用非受控组件，因为实际情况下我们需要更多的考虑表单验证、选择性的开启或者关闭按钮点击、强制输入格式等功能支持，而此时我们将数据托管到 React 中有助于我们更好地以声明式的方式完成这些功能。引入 React 或者其他 MVVM 框架最初的原因就是为了将我们从繁重的直接操作 DOM 中解放出来。 shouldComponentUpdate 的作用是啥以及为何它这么重要？ shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。 createElement 与 cloneElement 的区别是什么？ createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。 为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？ props.children并不一定是数组类型，譬如下面这个元素： 123&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt;&lt;/Parent&gt; 如果我们使用props.children.map函数来遍历时会受到异常提示，因为在这种情况下props.children是对象（object）而不是数组（array）。React 当且仅当超过一个子元素的情况下会将props.children设置为数组，就像下面这个代码片： 1234&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt; &lt;h2&gt;props.children will now be an array&lt;/h2&gt;&lt;/Parent&gt; 这也就是我们优先选择使用React.Children.map函数的原因，其已经将props.children不同类型的情况考虑在内了。 如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？ 1234567891011121314151617181920212223&lt;Twitter username="tylermcginnis33"&gt; &#123;user =&gt; (user === null ? &lt;Loading /&gt; : &lt;Badge info=&#123;user&#125; /&gt;)&#125;&lt;/Twitter&gt;;import React, &#123; Component, PropTypes &#125; from 'react'import fetchUser from 'twitter'class Twitter extends Component &#123; state = &#123; user: null, &#125; static propTypes = &#123; username: PropTypes.string.isRequired, &#125; componentDidMount () &#123; fetchUser(this.props.username) .then((user) =&gt; this.setState(&#123;user&#125;)) &#125; render () &#123; return this.props.children(this.state.user) &#125;&#125; 在生命周期中的哪一步你应该发起 AJAX 请求？我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下： React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。 什么是JSX 就是为了把 HTML 模板直接嵌入到 JS 代码里面，这样就做到了模板和组件关联，但是 JS 不支持这种包含 HTML 的语法，所以需要通过工具将 JSX 编译输出成 JS 代码才能使用 props 和 state props是组件的属性，只读 state是当前组件的状态，是私有的。 为什么我们利用循环产生的组件中要用上key这个特殊的prop？ 有babel转换后React.createElement中的代码可以看出，其它元素之所以不是必须需要key是因为不管组件的state或者props如何变化，这些元素始终占据着React.createElement固定的位置，这个位置就是天然的key。 而由数组创建的组件可能由于动态的操作导致重新渲染时，子组件的位置发生了变化，例如上面用户列表子组件新增一个用户，上面两个用户的位置可能变化为下面这样： 12345678910var element = React.createElement( "div", null, React.createElement("h3",null,"用户列表"), [ React.createElement("div",&#123; key: 3 &#125;,"1:王五"), React.createElement("div",&#123; key: 1 &#125;,"2:张三"), React.createElement("div",&#123; key: 2 &#125;,"3:李四") ]); 可以看出，数组创建子组件的位置并不固定，动态改变的；这样有了key属性后，react就可以根据key值来判断是否为同一组件。 组件的Render函数在何时被调用 如果单纯、侠义的回答这个问题，毫无疑问Render是在组件 state 发生改变时候被调用。无论是通过 setState 函数改变组件自身的state值，还是继承的 props 属性发生改变都会造成render函数被调用，即使改变的前后值都是一样的。 如果你想手动决定是否调用也没有问题，如果你还记得React的生命周期的话，一定记得有一个boolean shouldComponentUpdate(object nextProps, object nextState)生命周期函数，这个函数的返回值决定了Render是否被调用，默认都返回true，即允许render被调用。如果你对自己的判断能力有自信，你可以重写这个函数，根据参数判断是否应该调用 Render 函数。这也是React其中的一个优化点。 render函数被调用了，DOM就一定被更新了？ 这要看更新的是哪一类DOM了。 React组件中存在两类DOM，一类是众所周知的Virtual DOM，相信大家也耳熟能详了；另一类就是浏览器中的真实DOM（Real DOM/Native DOM）。React的Render函数被调用之后，React立即根据props或者state重新创建了一颗Virtual DOM Tree，虽然每一次调用时都重新创建，但因为在内存中创建DOM树其实是非常快且不影响性能的，所以这一步的开销并不大。而Virtual DOM的更新并不意味这Real DOM的更新，接下来的事情也是大家知道的，React采用算法将Virtual DOM和Real DOM进行对比，找出需要更新的最小步骤，此时Real DOM才可能发生修改。每一次的state更改都会使得render函数被调用，但页面的DOM不一定会发生修改 React NativeRN如何与原生iOS交互RN与IOS的通信 React Native用iOS自带的JavaScriptCore作为JS的解析引擎 有两份模块配置表：OC端和JS端分别各有一个bridge，两个bridge都保存了同样一份模块配置表 JS调用OC模块方法时，通过bridge里的配置表把模块方法转为模块ID和方法ID传给OC OC通过bridge的模块配置表找到对应的方法执行之 RN在iOS中的操作是：在IOS中： 取所有模块类每个模块类都实现了RCTBridgeModule接口通过runtime接口objc_getClassList或objc_copyClassList取出项目里所有类然后逐个判断是否实现了RCTBridgeModule接口，就可以找到所有模块类，实现在RCTBridgeModuleClassesByModuleID()方法里。 取模块里暴露给JS的方法可以定义一些能被js访问或者不能被js访问的方法，比如Allow_JS_为前缀的就可以访问用runtime方法class_getInstanceMethod取出所有方法名字，提取以RCTExport_为前缀的方法 JS —- Objective-C 调用Objective-C提供出来的某个方法ABC，将JS代码填充进入 进入JS Bridge 把上一步的调用，分解为模块名(ModuleName)，方法名(MethodName)，对callback进行一些处理，放到一个信息队列里面(MessageQueue)。 进入MessageQueue，用上一步的callback生成对应的CallbackID。拿到上一步中MessageQueue的模块配置表的ModuleName和MethodName转为ModuleID和MethodID。离开JS Bridge 把上述步骤得到的ModuleID,MethodId,CallbackID和其他参数argus传给OC 进入OC Bridge OC接收到消息，通过模块配置表拿到对应的模块和方法。在这一步，OC Bridge已经初始化了。在OC Bridge初始化的时候，每一个模块生成了对应的实例，模块上的每一个方法也都生成了对应的RCTModuleMethod对象。我们就可以同上前面拿到的ModuleID,MethodId,CallbackID和其他参数 进行操作 RCTModuleMethod对JS传过来的每一个参数进行处理。在这一步中 OC会把JS的参数类型转为自己OC对应的参数类型，还会生成一个block,等执行完js的时候再来执行我没写过ios,但我的理解是这个block类似于js中的单层回调block:类似js的单层回调离开OC Bridge OC模块方法调用完，执行block回调。 返回过来的时候，我们刚已经记录了block callbackID 和 callbackID对应的callback方法，这样 我们就可以按原路返回到js端 runtime接口可以理解为一个运行时的事件，运行后就可以得到所有类 如 objc_getClassList或objc_copyClassList 与iOS交互图解 参考: React Native通信机制详解 RN如何与原生Android交互 在Android系统上已经有了实现。就是WebView。然而React-Native与WebView并没有一点关系。React-Native实现一套新的webview JavascriptModuleRegistry：Js层模块注册表，负责将所有JavaScriptModule注册到CatalystInstance，通过Java动态代理调用到Js。 java通过注册表调用到CatalystInstance实例，透过ReactBridge的jni，调用到Onload.cpp中的callFunction，最后通过javascriptCore，调用BatchedBridge.js，根据参数｛moduleID,methodID｝require相应Js模块执行 js -&gt; Java：JS不主动传递数据调用Java。在需要调用调Java模块方法时，会把参数｛moduleID,methodID｝等数据存在MessageQueue中，等待Java的事件触发，再把MessageQueue中的｛moduleID,methodID｝返回给Java，再根据模块注册表找到相应模块处理。 Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 容器的属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 justify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 如何更新jsbundle 我们打好包jsbundle文件放到远程服务器 启动React Native, 检查sdcard是否有jsbundle文件, 如果没有调用setBundleAssetName(该方法存在React Native 启动入口)加载asset目录的jsbundle, 同时启动线程下载远程jsbundle文件到sdcard目录. 待下次启动时, sdcard是有jsbundle文件的, 加载的就是最新的jsbundle文件. Hot Replacement/请简述 code push 的原理？code push 调用 react native 的打包命令，将当前环境的非 native 代码全量打包成一个 bundle 文件，然后上传到微软云服务器（Windows Azure）。在 app 中启动页（或 splash 页）编写请求更新的代码（请求包含了本地版本，hashCode、appToken 等信息），微软服务端对比本地 js bundle 版本和微软服务器的版本，如果本地版本低，就下载新的 js bundle 下来后实现更新(code push 框架实现)。 CodePush 可以进行实时的推送代码更新： 直接对用户部署代码更新 管理 Alpha，Beta 和生产环境应用 支持 React Native 和 Cordova 支持JavaScript 文件与图片资源的更新 首屏优化 首屏耗时=react native上下文初始化耗时+首屏视图渲染耗时 根据生命周期，有初始阶段，更新阶段和卸载组件阶段 在初始阶段首先渲染loading视图，获取数据后，通过改变状态（state），触发视图的再次渲染，在屏幕绘制出视图。 可以通过控制台打印的方式或者日志输出的方式去监听时间 加上缓存，RN有一个AsyncStorage类似localStorage,第一次进入的时候加上缓存，再下次进入的时候不进入loading,而是直接获取上一次缓存数据，在做网络请求 shouldComponentUpdate中判断缓存数据与网络响应数据的差别 参考:探索react native首屏渲染最佳实践 RN的优缺点React Native相对于原生的ios和Android有哪些优势？ 跳过App Store审核，远程更新代码，提高迭代频率和效率，既有Native的体验，又保留React的开发效率。 性能媲美原生APP 使用JavaScript编码，只要学习这一种语言 绝大部分代码安卓和IOS都能共用 组件式开发，代码重用性很高 跟编写网页一般，修改代码后即可自动刷新，不需要慢慢编译，节省很多编译等待时间 支持APP热更新，更新无需重新安装APP 缺点内存占用相对较高对于不熟悉前端开发的人员上手比较慢，不能真正意义上做到跨平台，使用后，对app体积增加。 各个框架比较React 和 Vue 有许多相似之处 它们都是JavaScript的UI框架 使用 Virtual DOM 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。 追踪变化/更新DOM/视图渲染/Vue和React的设计思想有什么区别 简述：vue是采用双向绑定去做数据更新，视图渲染。而react是单向的，通过对比状态差异更新。 vue: (可以对着图片想象) 对数据进行劫持监听,当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。 实现一个订阅者Watcher，为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 实现一个解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 react: setState() 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程 调和过程后有一个新的UI树，这个UI树需要跟旧的UI树做对比。采用Diff算法，不同节点类型的比较 ，分两种情况： 节点类型不同： 直接删除旧的节点，再新建新的节点 节点类型相同，属性不同： 对比属性，只改变变化了的节点属性 构建 React 元素树并且着手重新渲染整个UI界面 shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate 在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 数据绑定 vue 是 双向绑定 react 是 单向的 数据流 vue 父子组件之间的数据通信是通过Prop和自定义事件实现的 使用 events 向父组件发送消息： 向父组件发送事件，我们可以调用实例中内置的 $emit 方法 通过 v-on 监听这个事件 非父子组件可以使用订阅/发布模式实现（类似于Angualr中的非父子指令之间的通信） React 父与子之间的数据通信是通过props属性就行传递的 子与父之间的数据通信可以通过父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信 非父子组件之间的通信：React中在处理非父子组件之间的通信时，简单的，嵌套不深的非父子组件（如：兄弟组件）可以仍然使用上一节非父子组件之间通信中的事件函数，传形参的方式来实现。深层的话可以用redux管理 编写方式 Template vs jsx vue是用模板，Vue鼓励你去写近似常规HTML的模板 React推荐你所有的模板通用JavaScript的语法扩展——JSX书写 状态管理 vue数据由data属性在Vue对象中进行管理 reactreact 采用state去管理它的状态，state对象在React应用中是不可变的，意味着它不能被直接改变（这也许不一定正确）。在React中你需要使用setState()方法去更新状态 Vue和React的有什么优劣Vue的优势（性能方面） vue在更新数据时会定位到某个状态如何就去修改它，因为这个监听从一开始就已经被绑定。而react是当一个节点类型发生变化，该节点包含节点下所有子节点均会被删除。 在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。而Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。 双向绑定：这样开发过程快速找到某个值，实时反应用户输入的场合会非常方便 React的优势 有Facebook背景。像 React Native，React VR这种量级的生态圈是很重要的考量; 社区活跃，大量react周边产物，如蚂蚁金福的ant design; 高度组件化，我可以一层一层地拆 很清晰 React 采用虚拟DOM，js操作比DOM操作快多了在大数据的情况下，React的运行效率是最高的 基于v-dom的UI框架: 采用virtual dom render + diff进行必要的DOM渲染。这样的好处是我们可以采用一种比重置innerHtml 更高效的方法更新DOM元素。在过往我们写的DOM元素是需要调出DOM然后再对它操作，因此导致页面reflow或repaint,而react是所有元素置于v-dom，即完完全全在JavaScript中曲操作DOM，这样开销就小了很多。 学习成本 vue对新手更友好，react相对来说学习路线更陡；个人觉得，react写起来更优雅。 AngularJS适用于CRUD操作的web应用，不适用与游戏、图形编辑器这种DOM操作频繁的web应用。目前功能比较齐全。 react可以拓展到服务端、移动端native部分，支持跨平台，比如React Native,React VR vue最轻量、还可以用于业务场景非常轻的页面中（不用全家桶也不错） 状态：MVVM模型的有angular和vue 实行的是数据双向绑定。react是采用单向数据流。 组织：组件化能提高开发维护效率，目前对三个框架，React组件化最好 效率 开发效率 组件化会提高效率，具体到每个组件的实现，MVVM代码量少一些 运行效率 Angular的运行效率是最低的，因为它用到了脏检查，在应用运行的过程中，需要不断地操作 DOM，会造成明显的卡顿。 React 采用虚拟DOM，js操作比DOM操作快多了在大数据的情况下，React的运行效率是最高的 单向数据绑定和双向数据绑定 单向数据绑定：复杂应用来说这是实施统一的状态管理 双向数据绑定：实时反应用户输入的场合会非常方便 如何选择框架开发的业务需求，模块需求（组件化这块），开发效率，运行效率，和框架的使用场景.团队成员对框架的熟悉程度]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>Angular</tag>
        <tag>VUE</tag>
        <tag>ReactJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP | 面试总结]]></title>
    <url>%2F2018%2F06%2F28%2Finterview-http%2F</url>
    <content type="text"><![CDATA[跨域手写一个JSONP的实现123456&lt;script&gt; callback(res)&#123; console.log(res); &#125;&lt;/script&gt;&lt;script src="xxx/test.js?callback=callback"&gt;&lt;/script&gt; 12// test.jscallback(data) 跨域的方式? 客户端 jsonp：原理：通过&lt;script&gt;标签请求,再用callback函数返回需要的字段。因为Web页面上调用js文件时则不受是否跨域的影响 document.domain：通过修改该字段来跨子域，但只适用于不同子域的框架间的交互。 window.name:这种方法与document.domain 方法相比，放宽了域名后缀要相同的限制，可以从任意页面获取 string 类型的数据 postMessage 服务端 CORS： 服务器 在响应头中设置相应的选项（Access-Control-Allow-Origin 和 Access-Control-Allow-Credentials） 代理 Nginx 参考：前端模拟服务器实现跨域 | Abigalehtml5 postMessage解决跨域、跨窗口消息传递 jsonp安全漏洞 xss:callback里传入 callback=&lt;script&gt;xx&lt;script&gt; 解决办法：Content-Type: application / json 只能传入json csrf:json劫持 123456&lt;script&gt;function wooyun(v)&#123; alert(v.username);&#125;&lt;/script&gt;&lt;script src="http://js.login.360.cn/?o=sso&amp;m=info&amp;func=wooyun"&gt;&lt;/script&gt; 这个是在乌云网上报告的一个攻击例子（ WooYun-2012-11284 ）http://www.wooyun.org/bug.php?action=view&amp;id=11284 当被攻击者在登陆 360 网站的情况下访问了该网页时，那么用户的隐私数据（如用户名，邮箱等）可能被攻击者劫持。 参考：JSONP 安全攻防技术 缓存HTTP协议缓存的实现以下是后端控制的缓存 强缓存的方法：expire 和 cache-control 协商缓存的方法：last-modified/Last-modified-since 和 ETag 和 If-None-Match 静态文件的缓存/如果服务器端更新脚本，如何保证客户端不受缓存机制影响，实时更新脚本 在文件后加版本号 如xxx.js?v=1.1.1 拼接文件名 如 xxx111111.js 参考：对浏览器做一些缓存 | Abigale 前端存储对比 存储量 存储类型 使用方式 数据的生命期 与服务器端通信 优点 缺点 存储量 cookie: 4KB sessionStorage: 一般为5MB localStorage: 一般为5MB 存储类型 cookie: 字符串 sessionStorage: 键值对 localStorage: 键值对 使用方式 cookie: 获取 cookie 可以直接使用 document.cookie ，但是获取到的 cookie 是一个字符串，它包含了 cookie 中存储的所有数据，形式如 &quot;key1=value1; key2=value2&quot; sessionStorage: 普通对象非常相似，可以直接通过中括号 sessionStorage[‘key’] 的方式添加和获取数据，也可以通过点语法 sessionStorage.key 的方式进行操作，sessionStorage 也有自己的 api 用于操作数据。或者sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;)；var data = sessionStorage.getItem(&#39;key&#39;) localStorage: 同上 数据的生命期 cookie: 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 sessionStorage: 仅在当前会话下有效，关闭页面或浏览器后被清除 localStorage: 除非被清除，否则永久保存 与服务器端通信 cookie: 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 sessionStorage: 仅在客户端（即浏览器）中保存，不参与和服务器的通信 localStorage: 同上 优点 cookie: 有大量的库可供我们更方便快捷得操作 cookie ，如 jQuery.cookie.js sessionStorage: 存储的数据不会被自动随着请求被发送到服务端 可存储的数据大小相比 cookie 来说大了很多，但是每个浏览器都不同，所以没有一个统一的值。 localStorage: 数据存储量大； 不会被发送到服务端； 持久化本地存储，除非手动删除，否则一直存在； 在同一个域下，所有窗口共享其中存储的数据 (sessionStorage则不可) 缺点 cookie: 如 &quot;key1=value1; key2=value2&quot; 这样的字符串无法通过 JSON.parse() 转换为 json 格式的数据，需要通过正则表达式的方式将所需要的值匹配出来 sessionStorage: sessionStorage 中只能够保存字符串类型的数据，所以在保存非字符串类型的数据时，一定要先将其转换成字符串，比如图片可以转换成 base64 字符串后保存，对象可使用 JSON.stringify() 转为字符串后存储，甚至可以存储一段 js 脚本 其中所存储的数据的生命周期与 session 类似，即只存在于一个会话周期内，当浏览器关闭或标签页关闭时，数据即会被删除（前进和后退并不会影响到数据，因为还在当前的会话中），这就导致了即便是同一个网站，但在不同的标签页和窗口内，也无法共享其中存储的数据 localStorage: 只能够保存字符串类型的数据，所以在保存非字符串类型的数据时，一定要先将其转换成字符串，比如图片可以转换成 base64 字符串后保存，对象可使用 JSON.stringify() 转为字符串后存储，甚至可以存储一段 js 脚本 参考 前端本地存储策略 | Abigale 状态码1xx: 信息 100 Continue 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 2xx: 成功 200 OK 请求成功（其后是对GET和POST请求的应答文档。） 201 Created 请求被创建完成，同时新的资源被创建。 202 Accepted 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。 3xx: 重定向 300 Multiple Choices 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently 所请求的页面已经转移至新的url。 302 Found 所请求的页面已经临时转移至新的url。 303 See Other 所请求的页面可在别的url下被找到。 304 Not Modified 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取。 306 Unused 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect 被请求的页面已经临时移至新的url。 4xx: 客户端错误 400 Bad Request 服务器未能理解请求。 401 Unauthorized 被请求的页面需要用户名和密码。 402 Payment Required 此代码尚无法使用。 403 Forbidden 对被请求页面的访问被禁止。 404 Not Found 服务器无法找到被请求的页面。 405 Method Not Allowed 请求中指定的方法不被允许。 5xx: 服务器错误 500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。 501 Not Implemented 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway 请求未完成。服务器从上游服务器收到一个无效的响应。 503 Service Unavailable 请求未完成。服务器临时过载或当机。 504 Gateway Timeout 网关超时。 505 HTTP Version Not Supported 服务器不支持请求中指明的HTTP协议版本。 Ajax什么是 Ajax，它们的优缺点。Ajax 是异步 JavaScript 和 XML，用于在 Web 页面中实现异步数据交互。 Ajax 优点 可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量 避免用户不断刷新或者跳转页面，提高用户体验 Ajax 缺点 对搜索引擎不友好 （解释：因为 ajax 内容是动态爬取的，而爬虫只能爬页面一开始的 HTML） 要实现 ajax 下的前后退功能成本较大（AJAX 干掉了 Back 和 History 功能，即对浏览器机制的破坏） 可能造成请求数的增加（增大网络数据的流量是因为要发很多次请求才能把页面渲染出来） 跨域问题限制 ajax 如何实现首先实现 ajax 之前必须要创建一个 XMLHttpRequest 对象的 –&gt; open –&gt; send GET 1234567891011121314&lt;script&gt; let requestData = document.getElementsByClassName("responseText")[0]; let requestHeader = document.getElementsByClassName("requestHeader")[0]; let request = new XMLHttpRequest(); request.open('GET', 'http://127.0.0.1:8080/test.txt'); request.send(); request.onreadystatechange = function () &#123; console.log(request) if (request.readyState == 4) &#123; requestData.innerHTML = `&lt;pre&gt;$&#123;request.responseText&#125;&lt;/pre&gt;` requestHeader.innerHTML = `&lt;pre&gt;$&#123;request.getAllResponseHeaders()&#125;&lt;/pre&gt;` &#125; &#125; &lt;/script&gt; POST 123456789101112131415161718&lt;script&gt; let requestData = document.getElementsByClassName("responseText")[0]; let requestHeader = document.getElementsByClassName("requestHeader")[0]; let request = new XMLHttpRequest(); request.open('GET', 'http://127.0.0.1:8080/test.txt'); let params = &#123; name: 'abigale', age: 18 &#125; request.send(params); request.onreadystatechange = function () &#123; console.log(request) if (request.readyState == 4) &#123; requestData.innerHTML = `&lt;pre&gt;$&#123;request.responseText&#125;&lt;/pre&gt;` requestHeader.innerHTML = `&lt;pre&gt;$&#123;request.getAllResponseHeaders()&#125;&lt;/pre&gt;` &#125; &#125; &lt;/script&gt; Ajax 状态readyState 属性 状态 有 5 个可取值： 0 = 未初始化，1 = 启动， 2 = 发送，3 = 接收，4 = 完成 Ajax 同步和异步的区别: 同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回，这个期间客户端浏览器不能干任何事 异步：请求通过事件触发 -&gt; 服务器处理（这是浏览器仍然可以作其他事情）-&gt; 处理完毕ajax.open 方法中，第 3 个参数是设同步或者异步。 手写一个Ajax的Promise封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function GET(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr; if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('GET', url, true) xhr.onreadystatechange = function (e) &#123; if (xhr.readyState == 4) &#123; if (this.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125;function postJSON(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr; if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open("POST", url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125;let url = 'https://api.github.com/'GET(url).then(res =&gt; &#123; console.log(res);&#125;).catch(error =&gt; &#123; console.error(error);&#125;) GET和POSTGET和POST的区别 GET用于信息获取，而且应该是安全的和幂等的。（幂等就是每次请求结果都一样）；POST表示可能修改变服务器上的资源的请求。Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求 GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连；POST把提交的数据则放置在是HTTP包的包体中。 GET方式提交的数据最多只能是1024字节；POST是没有大小限制的，HTTP协议规范也没有进行大小限制 GET能被缓存，POST不能缓存。 URL到渲染浏览器从URL到页面渲染经历了哪些？ 域名解析成IP 找到IP对应服务器 发送HTTP请求 响应HTTP请求 渲染页面 域名解析IP寻找路径 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 一个完整的HTTP请求过程,通常有下面7个步骤 建立TCP连接 Web浏览器向Web服务器发送请求命令 Web浏览器发送请求头信息 Web服务器- 应答 Web服务器- 发送响应头信息 Web服务器- 向浏览器发送数据 Web服务器- 关闭TCP连接 &gt; 可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据查询、浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细解释 浏览器会开启一个线程来处理这个请求，对 URL 分析判断，如果是 http 协议就按照 web 方式来处理； 调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法； 通过 DNS 解析获取网址的 IP 地址，设置 UA 等信息发出第二个 GET 请求； 进行 HTTP 协议会话，客户端发送报头（请求报头）； 进入到 web 服务器上的 Web Server，如 Apache、Tomcat、Node.js 等服务器； 进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理； 处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改事件对比，一致则返回304； 浏览器开始下载 html 文档（响应报头，状态码200），同时使用缓存； 文档树建立，根据标记请求所需指定 MIME 类型的文件（比如css、js），同时设置 cookie； 页面开始渲染 DOM ，JS 根据 DOM API 操作 DOM ，执行事件绑定等，页面显示完成； 概要 浏览器根据请求的 URL 交给 DNS 域名解析，找到真实 IP ，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、CSS、JS、image等）； 浏览器对加载到的资源（HTML、CSS、JS等）进行语法解析，建立相应的内部数据结构（如 HTML 的 DOM ）；载入解析到的资源文件，渲染页面，完成。 如何渲染页面 请求HTML文件解析成DOM树 关联到CSS解析成CSSOM DOM和CSSOM构造Render Tree 边计算边绘制 MethodHttp协议中有那些请求方式？ GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： PUT请求是向服务器端发送数据的，从而改变信息，该请求就像数据库的update操作一样 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 HTTPS原理原理 HTTPS其实是有两部分组成：HTTP + SSL / TLS 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书 可以自己制作 也可以向组织申请区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务) 证书：公钥 和 私钥 私钥存于服务端 和 客户端 公钥用于两端之间传送信息。比如有参数，则参数+公钥传送 HTTPS 过程包括域名解析IP 三次握手 后 建立TCP连接 然后SSL握手过程 TCP连接关闭 HTTPS - SSL握手过程 客户端首先会将自己支持的加密算法，打个包告诉服务器端 服务器端从客户端发来的加密算法中，选出一组加密算法和HASH算法。并将自己的身份信息以证书的形式发回给客户端。而证书中包含了网站的地址，加密用的公钥，以及证书的颁发机构等； 客户端收到了服务器发来的数据包后 验证一下证书是否合法 合法的话，客户端就会随机产生一串序列号，+ 公钥 一串序列号 + 加密算法 生成 消息校验值 发给服务端 服务端接收后 使用私钥解密 刚才上一步的2 （产生一串序列号，+ 公钥 ） 得到序列号 使用序列号 加密后看是否与上一步的3 一致 序列号 + 选择的加密算法，加密一段握手消息，发还给客户端。同时HASH值也带上。 客户端收到服务器端的消息后，接着做这么几件事情： 计算HASH值是否与发回的消息一致 检查消息是否为握手消息 HTTP的缺点与HTTPS 通信使用明文不加密，内容可能被窃听 不验证通信方身份，可能遭到伪装 无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护 参考：https原理：证书传递、验证和数据加密、解密过程解析简单粗暴系列之HTTPS原理 证书内容包括： 证书序列号 证书过期时间 证书颁发者的名称 证书颁发者的签名 站点的组织名 站点的DNS主机名 站点的公开密钥 浏览器如何验证服务器数字证书？ 验证是否在有效期内：已过去 或者 未激活 签名颁发者的可信度：每个证书都是由某些证书颁发机构(CA)签发的。浏览器会附带一个 签名颁发机构的授信列表 签名检测：获取到公开密钥 站点身份检测：因有些服务器会盗用其他证书，所以要验证证书中主机名是否与发送过来的服务器匹配 证书包含信息 端口号端口，是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等 端口号的作用端口号就是为了区分同一计算机上的不同进程区分服务，在一个服务器上启动多个服务 不同版本HTTP对比HTTP1.0 HTTP1.1 HTTP2.0 区别HTTP1.0 HTTP1.1 区别* 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略 * 节约带宽：HTTP1.1支持断点续传。HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。HTTP1.1则在请求头引入了range头域 * HOST域：HTTP1.0是没有host域的，HTTP1.1才支持这个参数。 * 长连接：在HTTP1.1中默认开启Connection： keep-alive，支持一次建立TCP发送多个http请求。 * 增加状态码：比如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 HTTP1.1 HTTP2.0 区别* 多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以建立多次TCP请求，但毕竟需要开销。 * 数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 * 服务器推送：意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。 参考：浅析HTTP/2的多路复用HTTP/2 服务器推送（Server Push）教程 HTTP2.0 header如何压缩头部压缩需要的支持HTTP/2的浏览器和服务端之间： 维护一份相同的静态字典，包含常见的头部名称，以及特别常见的头部名称与值的结合 维护一份相同的动态字典，可以动态添加内容 支持基于静态哈夫曼码表的哈夫曼编码 参考：HTTP/2 头部压缩技术介绍 请求头请求头12345678910111213141516171819202122232425a、通用首部字段（请求报文与响应报文都会使用的首部字段）Date：创建报文时间Connection：连接的管理 如：Connection:Keep-Alive: timeout=5, max=100 (保持5秒，max=100)Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式b、请求首部字段（请求报文会使用的首部字段）Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言c、响应首部字段（响应报文会使用的首部字段）Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 HTTP优化 利用负载均衡优化和加速HTTP应用 利用HTTP Cache来优化网 消息推送Web应用从服务器主动推送Data到客户端有哪些方式？ HTML5提供的WebSocket服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 12345678910111213141516var socket = new WebSocket('ws://localhost:8080/');socket.onopen = function () &#123; // 当ws连接建立时触发 console.log('Connected!');&#125;;socket.onmessage = function (event) &#123; // 当有信息到来时触发 console.log('Received data: ' + event.data); socket.close();&#125;;socket.onclose = function () &#123; // 当连接断开时触发 console.log('Lost connection!');&#125;;socket.onerror = function () &#123; // 当连接发生错误时触发 console.log('Error!');&#125;;socket.send('hello, world!'); readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。下面是一个示例。 1234567891011121314151617switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; 参考: WebSocket | MDN 其他推送方法 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming &lt;script&gt;标签的长时间连接（可跨域） cookiecookie是存在哪一部分？请求头。 个人理解：我们请求页面的时候，后端返回的响应头里如果有 Set-Cookie的话，浏览器会自动在缓存里设置这个cookie，当我们下次访问的这个域的时候，就会自动带上这个cookie。比如自动登录，后端返回在请求头token，浏览器就会写在缓存。但当我们访问一个从来没访问过的页面时，就不会带上cookie去访问这个页面，也没有默认cookie可言。 cookie和session的区别 cookie机制采用的是在客户端保持状态的方案 session机制采用的是在服务器端保持状态的方案。 (abigale: session是后端识别用户的一个方案，比如当A用户访问我某网站，网站服务器会在set-cookie返回一个session.XXX,当下次用户再访问时，浏览器会将它的cookie带过来，服务器就能识别哪个用户访问了。) 参考：cookie 和session 的区别详解 三次握手和四次挥手三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手四次挥手的过程如下： 客户端A上的某个进程，主动关闭连接，发送FIN（seq = u）报文给B，然后进入FIN_WAIT_1状态； B收到FIN报文，回应一个ACK （ACK = u + 1）报文，进入CLOSED_WAIT状态；A收到FIN报文，进入FIN_WAIT_2状态； B向A发送FIN（seq = v）报文，进入LAST_ACK状态； A收到FIN报文后，向B发送ACK(ACK = v + 1)报文，进入TIME_WAIT状态四次挥手后，A和B成功地断开了连接 HTTP包一个响应包123456789101112131415161718HTTP/1.1 304 Not ModifiedDate: Thu, 07 Jun 2018 15:31:47 GMTServer: TengineX-Frame-Options: DENYX-XSS-Protection: 1; mode=blockX-Content-Type-Options: nosniffETag: W/&quot;183130644061a9eb718916f4cad59080&quot;Cache-Control: max-age=0, private, must-revalidateSet-Cookie: locale=zh-CN; path=/Set-Cookie: _m7e_session=af038fcc6b2acd80ae604e1fe2b3e21b; path=/; expires=Thu, 07 Jun 2018 21:31:47 -0000; secure; HttpOnlyX-Request-Id: ea9c26da-5742-491d-91a8-fb0b557a1193X-Runtime: 0.044304Strict-Transport-Security: max-age=31536000; includeSubDomains; preloadX-Via: 1.1 PSfjfzdx2ec90:2 (Cdn Cache Server V2.0), 1.1 uzhoudianxin12:9 (Cdn Cache Server V2.0)Connection: keep-aliveX-Dscp-Value: 0&#123;&quot;reward_description&quot;:&quot;超值&quot;,&quot;reward_default_amount&quot;:200,&quot;rewards_count&quot;:0,&quot;rewards&quot;:[]&#125; 一个请求包1234567891011GET /u010429424/article/GetRelatedArticles?pageindex=2&amp;articleId=77340422 HTTP/1.1Host: blog.csdn.netConnection: keep-aliveAccept: */*X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36X-Tingyun-Id: wl4EtIR_7Is;r=421683836Referer: https://blog.csdn.net/u010429424/article/details/77340422Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: uuid_tt_dd=10_30743115060-1512117356324-203925; __yadk_uid=vyatSvYGWKohHCDsMbXTxoTJBorYYR5F; Hm_ct_6bcd52f51e9b3dce32bec4a3997715ac=1788*1*PC_VC; gr_user_id=bcadf7e4-940e-4dc2-b1a0-184a382e9432; pt_7cd998c4=uid=nf08JqHE-UNPGkKoiNhnJQ&amp;nid=0&amp;vid=Q/QhGM5QhPc7SI-8uAMaUQ&amp;vn=2&amp;pvn=1&amp;sact=1525597877046&amp;to_flag=1&amp;pl=brq8D7w/cJPhtNbSYn5y8w*pt*1525597857769; _dg_id.40e39cb6d36d5282.c482=27f20a36e99cc671%7C%7C%7C1525597025%7C%7C%7C1%7C%7C%7C1525603365%7C%7C%7C1525597861%7C%7C%7C%7C%7C%7C5b15a9e2e20d0230%7C%7C%7Chttps%3A%2F%2Fcn.bing.com%2F%7C%7C%7Chttps%3A%2F%2Fcn.bing.com%2F%7C%7C%7C0%7C%7C%7Cundefined; UM_distinctid=163a0a1912f4e-05b92e330d9e3-336c7706-13c680-163a0a19130af; CNZZDATA1261355189=647640448-1527407792-null%7C1527407792; dc_session_id=10_1528362022830.963824; dc_tos=p9zd1z; Hm_lvt_6bcd52f51e9b3dce32bec4a3997715ac=1528383298,1528385760,1528420827,1528421684; Hm_lpvt_6bcd52f51e9b3dce32bec4a3997715ac=1528421684 RESTful表现层状态转化 表现层: 资源 状态转化：一个过程， API定制 统一资源接口：GET，DELETE，PUT和POST 资源的表述：html、xml、json 在Content-Type中设定 以什么方式传参，以什么方式接收参数 URL中路径的设定：比如按类型划分 登录相关的 security 查看某某学院 school 查看某某学院的某个专业 school/computer 报文HTTP请求报文与响应报文格式请求报文包含四部分： 请求行：包含请求方法、URI、HTTP版本信息 请求首部字段 请求内容实体 空行 响应报文包含四部分： 状态行：包含HTTP版本、状态码、状态码的原因短语 响应首部字段 响应内容实体 空行 常见的首部：通用首部字段（请求报文与响应报文都会使用的首部字段） Date：创建报文时间 Connection：连接的管理 Cache-Control：缓存的控制 Transfer-Encoding：报文主体的传输编码方式 请求首部字段（请求报文会使用的首部字段） Host：请求资源所在服务器 Accept：可处理的媒体类型 Accept-Charset：可接收的字符集 Accept-Encoding：可接受的内容编码 Accept-Language：可接受的自然语言 响应首部字段（响应报文会使用的首部字段） Accept-Ranges：可接受的字节范围 Location：令客户端重新定向到的URI Server：HTTP服务器的安装信息 实体首部字段（请求报文与响应报文的的实体部分使用的首部字段） Allow：资源可支持的HTTP方法 Content-Type：实体主类的类型 Content-Encoding：实体主体适用的编码方式 Content-Language：实体主体的自然语言 Content-Length：实体主体的的字节数 Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 请求报文头 响应报文头]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS基础 | 面试总结]]></title>
    <url>%2F2018%2F06%2F28%2Finterview-basic-js%2F</url>
    <content type="text"><![CDATA[DOM 和 BOM 文档对象模型(DOM)：提供访问和操作网页内容的方法和接口 浏览器对象模型(BOM)：提供与浏览器交互的方法和接口 argumentsarguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性。例如，它没有 pop 方法。 转换为一个真正的Array：123456var args = Array.prototype.slice.call(arguments);var args = [].slice.call(arguments);var args = [...arguments]; // 扩展运算符方法// ES2015const args = Array.from(arguments); 关于类型 Object.prototype.toString.call(arguments); // “[object Arguments]” typeof arguments // Object 数据类型基础数据类型 string Number Boolean undefined Null 引用数据类型 Object(Array,Date,RegExp,Function) null 和 undefined 的异同 共同点 都是表示”无” 用if语句时，都会被转成false 不同点 null 是一个表示“无”的对象，转换为数字的时候是 0 undefined 是一个表示“无”的原始值，转换为数字时是 NaN 1234Number(null) // 0Number(undefined) // NaN5+null // 55+undefined // NaN Null典型用法 函数参数传递为空时，使用null 如 foo(null,null) 原型链的终点,如 Object.getPrototypeOf(Object.prototype) undefined典型用法 一个定义了的变量没有赋值 一个函数该给的参数没有给 一个对象的某个属性没有赋值 函数没有返回值时，默认为undefined 检测类型的方法 typeof 适用于基础类型 而不适合引用类型 12typeof undefined; //undefined 有效typeof null; //object 无效 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型 constructor 12let f = new F()f.constructor == F //true toString() 12let type = Object.prototype.toString.call(true)type.slice(8,-1) 类型转换，判断下列的真假123456789var undefined;undefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == ''; // trueNaN == NaN // false[]==![] // true[]==false // true 执行环境和作用域js 的作用域有几种？ 局部作用域 / 函数作用域(块级作用域) 全局作用域 作用域链当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 执行环境也就是函数之外那一层 无块级作用域：使用var时，变量会自动添加到最接近的环境（函数）中。 thisthis有哪些应用场景 作为对象方法调用 1234567var test = &#123; a:0, b:0 get:function()&#123; return this.a; // 对象方法调用 &#125;&#125; 作为构造函数的调用 1234function Point(x, y)&#123; this.x = x; this.y = y; &#125; 使用 call 和 apply 获取全局对象 参考：Javascript 的 this 用法 Tips this对象是在运行时基于函数的执行环境绑定的。普通函数调用，函数被谁调用，this就指向谁。 记住应当去看当前this指向哪里。普通函数定义时，它里面的this都指向全局(如案例三)。除非去根据构造函数new 一个实例，这个实例的this指向了它本身(案例六) 箭头函数和普通函数的this 原型链中的this:往上找 getter 与 setter 中的 this 作为一个内联事件处理函数：当代码被内联on-event 处理函数调用时，它的this指向监听器所在的DOM元素： 普通对象函数的this12345678910111213var fullname ='John Doe';var obj =&#123; fullname:'Colin Ihrig', prop:&#123; fullname:'Aurelio De Rosa', getFullname:function()&#123; return this.fullname; &#125; &#125;&#125;;console.log(obj.prop.getFullname()); // Aurelio De Rosavar test = obj.prop.getFullname;console.log(test()); // John Doe 闭包或普通函数的this123456789101112131415161718192021222324252627282930313233343536373839404142// 案例一：this 指向golbal/windowfunction f1(params) &#123; console.log(this); var abigale = 1 console.log(this.abigale);//undefined function f2() &#123; console.log(this.abigale);//undefined &#125; return f2()&#125;// 案例二：写了this function f1(params) &#123; console.log(this); this.abigale = 1 // 赋值到全局 console.log(this.abigale);//1 function f2() &#123; console.log(this.abigale);//1 &#125; return f2()&#125;// 案例三：在函数修改 但其实this指向全局，它其实是改了全局的thisthis.name = 'golbal'function test(params) &#123; this.name = 'local' return function () &#123; console.log(this.name); &#125;&#125;test()() //local// 案例四：this指向对象本身var fo = &#123; name :3, foo:function () &#123; console.log('------------------------------------'); console.log(this.name); console.log('------------------------------------'); &#125;&#125; 构造函数this 如果有new关键字，this指向new出来的那个对象eg: 如在浏览器下执行123456function F()&#123; console.log(this)&#125;F(); // windowlet f = new F() // 这一步会执行F(),且this指向F，而非window 匿名函数的this 参考：匿名函数的执行环境具有全局性《JavaScript高级程序设计》P182 123456789101112var obj = &#123; say: function () &#123; console.log(this) // &#123;say:function&#125; setTimeout(function () &#123; console.log(this) // window &#125;); (function () &#123; console.log(this) // window &#125;)() &#125;&#125;obj.say(); 123456789101112131415161718192021222324var obj = &#123; say: function () &#123; console.log(this) // &#123;say:function&#125; setTimeout(function () &#123; console.log(this) // window &#125;); this.a = function () &#123; console.log(this); //&#123;say:function,a:function&#125; &#125; this.a() &#125;&#125;obj.say();``` ### 严格模式下的this```js function test() &#123; 'use strict'; console.log(this); &#125; test(); //undefined 箭头函数中的 this123456789101112131415161718192021案例：普通函数和箭头函数var o = &#123; a:1, b:2, f: function() &#123; console.log( this.a + this.b); //3 &#125;&#125;;// 箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),而不是执行时的对象, 定义它的时候,可能环境是window; 箭头函数可以方便地让我们在 setTimeout ,setInterval中方便的使用this// * 普通函数this指向执行时调用它的对象// * 箭头函数this总是指向定义时所在的对象，而不是运行时所在的对象var c = &#123; a:1, b:2, f: () =&gt;&#123; console.log( this.a + this.b); // NaN 定义时没有this &#125;&#125;; 12345678var obj = &#123; say: function () &#123; setTimeout(() =&gt; &#123; console.log(this) &#125;); &#125;&#125;obj.say(); // obj 此时的 this继承自obj, 指的是定义它的对象obj, 而不是 window! 示例(多层嵌套的箭头函数): 123456789101112var obj = &#123;say: function () &#123; var f1 = () =&gt; &#123; console.log(this); // obj setTimeout(() =&gt; &#123; console.log(this); // obj &#125;) &#125; f1(); &#125;&#125;obj.say() 因为f1定义时所处的函数 中的 this是指的 obj, setTimeout中的箭头函数this继承自f1, 所以不管有多层嵌套,都是 obj 匿名函数,定时器中的函数,由于没有默认的宿主对象,所以默认this指向window 参考：深入理解ES6箭头函数的this以及各类this面试题总结 123456789101112131415161718192021222324252627282930function Parent() &#123; this.a = 1; this.b = [1, 2, this.a]; this.c = &#123; demo: 5 &#125;; this.show = function () &#123; console.log(this.a , this.b , this.c.demo ); &#125;&#125;function Child() &#123; this.a = 2; this.change = function () &#123; this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; &#125;&#125;Child.prototype = new Parent(); var parent = new Parent();var child1 = new Child();var child2 = new Child();child1.a = 11;child2.a = 12;parent.show(); child1.show(); child2.show(); child1.change();child2.change();parent.show();child1.show(); child2.show(); 创建对象(类)采用ES5创建对象/类可以先理清js下的类 类 没用于继承的话 它就是一个普通函数 类 就是 构造函数 构造函数 用来生成 特定类型 的对象 方法：记住各种弊端 工厂模式 123456789function createObject(name, age)&#123; let obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function()&#123; console.log(this.name) &#125; return obj;&#125; 弊端： 创建后无法识别是何种类型的对象 构造函数模式 1234567function Person(name, age)&#123; this.name = name; this.age = age; this.sayName = function()&#123; console.log(this.name) &#125;&#125; 与工厂模式不同的是： 不用显示new一个Object 将对象方法都赋予this 不用return 弊端： 方法不能共享，每个实例都会创建一个新的对象解决办法：可以将sayName方法写于类之外，然后this.sayName=全局的sayName但当有很多方法时全局写太多方法会不优雅而且混乱 原型式模式 12345678function Person()&#123;&#125;Person.prototype.name = 'abigale'Person.prototype.age = 18Person.prototype.sayName = function()&#123; console.log(this.name)&#125; 弊端： 不能传参 构造函数模式 + 原型式模式 结合 需要传参数的用构造函数模式 需要共享的用原型式模式 new 的过程经历哪些步骤 第一步: 创建一个Object对象实例。 第二步: 将构造函数的执行对象赋给新生成的这个实例。（也就是改变this的指向） 第三步: 执行构造函数中的代码 第四步: 返回新生成的对象实例 检测是否实例的各个方法 instanceof isPrototypeOf : Person.prototype.isPrototypeOf(person) Object.getPrototypeOf() : Object.getPrototypeOf(person) == Person.prototype 检测是否有某个属性 isOwnPrototype : person.isOwnPrototype(‘name’) in : ‘name’ in person 构造函数原型实例原型链理解： 构造函数：用来在创建对象时初始化对象。特点：构造函数名一般为大写字母开头；与new运算符一起使用来实例化对象,其中属性需要用this,否则跟普通函数无差别 原型：构造函数在创建的过程中，系统自动创建出来与构造函数相关联的一个空的对象。可以由构造函数.prototype来访问到。 实例 继承 原型链：每一个对象都有自己的原型对象，原型对象本身也是对象，原型对象也有自己的原型对象，这样就形成了一个链式结构，叫做原型链。 构造函数，原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。 原型和实例的关系：instanceof 和 isPrototypeOf 123// 判断A是否是B的实例，B是否是A的原型A instanceof BB.prototype.isPrototypeOf(A) 1var p = new Person() Person 为构造函数p 为实例Person.prototype 为原型 Person.prototype.constructor == Personperson.proto == Person.prototype 使用new关键字调用函数（new ClassA(…)）的具体步骤： 创建空对象:var obj = {}; 设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象:obj.proto = ClassA.prototype; 使用新对象调用函数，函数中的this被指向新实例对象：ClassA.call(obj); //{}.构造函数(); 将初始化完毕的新对象地址，保存到等号左边的变量中 参考:完整原型链详细图解（构造函数、原型、实例化对象） prototype和proto的关系是什么一个类的实例 的隐式原型(proto)指向 类的原型(prototype) 原型链图解 继承 原型链：采用实例的方式去继承，但会有两个弊端： 原型链中如果有变量是引用类型，该值会被共享 子类型无法向父类型传递参数 12345678910111213141516function Father()&#123; this.property = true;&#125;Father.prototype.getFatherValue = function()&#123; return this.property;&#125;function Son()&#123; this.sonProperty = false;&#125;//继承 FatherSon.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写Son.prototype.getSonVaule = function()&#123; return this.sonProperty;&#125;var instance = new Son();alert(instance.getFatherValue());//true 借用构造函数 再也不会被共享，每次都是有自己一个方法有些浪费资源 123456789101112131415161718192021222324252627282930313233343536373839404142 function Father()&#123; this.colors = ["red","blue","green"]; &#125; function Son()&#123; Father.call(this);//继承了Father,且向父类型传递参数 &#125; var instance1 = new Son(); instance1.colors.push("black"); console.log(instance1.colors);//"red,blue,green,black" var instance2 = new Son(); console.log(instance2.colors);//"red,blue,green" 可见引用类型值是独立的 ``` * 组合继承：使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承. ```js function Father(name)&#123; this.name = name; this.colors = ["red","blue","green"]; &#125; Father.prototype.sayName = function()&#123; alert(this.name); &#125;; function Son(name,age)&#123; Father.call(this,name);//继承实例属性，第一次调用Father() this.age = age; &#125; Son.prototype = new Father();//继承父类方法,第二次调用Father() Son.prototype.sayAge = function()&#123; alert(this.age); &#125; var instance1 = new Son("louis",5); instance1.colors.push("black"); console.log(instance1.colors);//"red,blue,green,black" instance1.sayName();//louis instance1.sayAge();//5 var instance1 = new Son("zhai",10); console.log(instance1.colors);//"red,blue,green" instance1.sayName();//zhai instance1.sayAge();//10 原型式继承:如果你指向让一个对象与另一个对象保持类似。（有一个对象可以作为另一个对象的基础）但与原型模型一样，引用类型会被共享 123456789101112// Object.create 的实现方式function object(o)&#123;// var F = function()&#123;&#125;// F.prototype = o;// return new F() var F = &#123;&#125; F.__proto__ = o.prototype; o.call(F) return F&#125;A = object(B) 寄生式继承：除了以另一个对象作为基础来继承，还为新对象添加新属性或方法，和借用构造函数模式相似 1234567function createAnother(original)&#123; var clone = object(original);//通过调用object函数创建一个新对象 clone.sayHi = function()&#123;//以某种方式来增强这个对象 alert("hi"); &#125;; return clone;//返回这个对象&#125; 闭包考点 执行环境 作用域链(变量)：本地活动对象 全局变量对象 闭包中this的指向 闭包的危害 闭包是什么一个函数里包含着另一个函数，内部函数可以访问函数外面的变量 闭包的作用/为什么要有闭包这种东西出现闭包通常用来创建内部变量，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作 闭包有什么副作用内存泄露因为内部函数引用了外部函数某个值时，这个值不管函数执行不执行都在内存中，解决办法是将该值设为null 有这样一个函数，如何让b 访问不到a1234function()&#123; var a=undefined; function b()&#123;&#125;&#125; js只有函数作用域，可以将a包裹在function或者IIFE中 其他题目123456789101112function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2;&#125;var result=f1();result(); // 999nAdd();result(); // 1000 123456789101112131415161718192021222324252627function creactFun()&#123; var result = new Array() for(var i=0;i&lt;10;i++)&#123; result[i] = function()&#123; return i; &#125; &#125;&#125;function creactFun()&#123; var result = new Array() for(var i=0;i&lt;10;i++)&#123; result[i] = function(num)&#123; return num; // 注意这样是错的 这样是返回一个值，上面返回是一个函数 &#125;(i) &#125;&#125;function creactFun()&#123; var result = new Array() for(var i=0;i&lt;10;i++)&#123; result[i] = function(num)&#123; return function()&#123; return num; &#125; &#125;(i) &#125;&#125; 1234567891011121314151617var name = "the window";var abc = &#123; name: "my object", getNameFunc: function () &#123; return function () &#123; return this.name &#125; &#125;&#125;;var name = "the window";var abc = &#123; name: "my object", getNameFunc: function () &#123; return this.name &#125;&#125;; 事件流模型Javascript 的事件流模型都有什么？优点？ “DOM 事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播事件捕获 事件捕获是从外层元素到目标元素的过程，事件冒泡是从目标元素到外层元素的过程 123&lt;div id="wrapper"&gt; &lt;button id="event"&gt;事件处理程序&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718var wrapper = document.getElementById('wrapper');var event = document.getElementById('event');// 理解事件流wrapper.addEventListener('click', function (e) &#123;console.log('捕获阶段执行父元素wrapper的事件处理程序');&#125;, true); // true - 事件句柄在捕获阶段执行 wrapper.addEventListener('click', function (e) &#123;console.log('冒泡阶段执行父元素wrapper的事件处理程序');&#125;, false); // false- 默认。事件句柄在冒泡阶段执行 event.addEventListener('click', function (e) &#123;console.log('捕获阶段执行子元素event的事件处理程序');&#125;, true); event.addEventListener('click', function (e) &#123;console.log('冒泡阶段执行子元素event的事件处理程序');&#125;, false); 输出结果 1234捕获阶段执行父元素wrapper的事件处理程序捕获阶段执行子元素event的事件处理程序冒泡阶段执行父元素wrapper的事件处理程序冒泡阶段执行子元素event的事件处理程序 阻止冒泡 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 123&lt;div id="propagation"&gt; &lt;button id="proEvent"&gt;阻止冒泡处理程序&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819// 阻止冒泡var propagation = document.getElementById('propagation');var proEvent = document.getElementById('proEvent');propagation.addEventListener('click', function (e) &#123; console.log('捕获阶段执行父元素propagation的事件处理程序');&#125;, true);propagation.addEventListener('click', function (e) &#123; console.log('冒泡阶段执行父元素propagation的事件处理程序');&#125;, false);proEvent.addEventListener('click', function (e) &#123; console.log('捕获阶段执行子元素proEvent的事件处理程序');&#125;, true);proEvent.addEventListener('click', function (e) &#123; e.stopPropagation(); console.log('冒泡阶段执行子元素proEvent的事件处理程序');&#125;, false); 输出结果 123捕获阶段执行父元素wrapper的事件处理程序捕获阶段执行子元素event的事件处理程序冒泡阶段执行父元素wrapper的事件处理程序 事件委托 事件委托就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 / 委托（代理）事件是那些被绑定到父级元素的事件，但是只有当满足一定匹配条件时才会被挪。这是靠事件的冒泡机制来实现的 事件委托有点 可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适 事件委托缺点 事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件。 1234567&lt;ul&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;banana&lt;/li&gt; &lt;li&gt;peal&lt;/li&gt; &lt;li&gt;cat&lt;/li&gt; &lt;li&gt;rabbit&lt;/li&gt;&lt;/ul&gt; 12345678910111213// 事件委托var li = document.getElementsByTagName('li');for (var i = 0; i &lt; li.length; i++) &#123; li[i].setAttribute('i', i + 1);&#125;var ul = document.getElementsByTagName('ul')[0];ul.addEventListener('click', function (e) &#123; var target = e.target; if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == 'LI') &#123; var b = e.target.getAttribute('i'); console.log('这是第' + b + '个&lt;li&gt;元素'); &#125;&#125;) 1234567var table = document.getElementsByTagName('table')[0];table.onclick= function (e) &#123; var target = e.target||e.srcElement; if(target.nodeName.toLowerCase()=='td')&#123; console.log('你点中一行'); &#125;&#125; target 和 currentTarget 的 区别event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素，只有被点击的那个目标元素的event.target才会等于event.currentTarget。 参考：event.target 和 event.currentTarget 的区别 对象属性类型 数据属性：configurale,enumerable,writable,value 12345678let obj = &#123; name:'abigale', address:'shenzhen'&#125;Object.defineProperty(obj, 'name', &#123; writable: false&#125;) // 不可修改name属性 访问器属性: configurale,enumerable,get,set 12345678910111213let obj = &#123; name:'abigale', address:'shenzhen'&#125;Object.defineProperty(obj, 'subname', &#123; get: function()&#123; return this.name &#125;, set: function(value)&#123; this.name = 'Yu ' + value &#125;&#125;) 对象的深拷贝 Object.assign() JSON.parse(JSON.stringify(data)) 箭头函数箭头函数和普通函数的区别this 普通函数this指向执行时调用它的对象 箭头函数this总是指向定义时所在的对象，而不是运行时所在的对象 普通函数 个人理解:可以理解为growUp并没有挂载到我们可以看到的对象里面 而是挂载到全局对象了 12345678910function Person(age) &#123; var _this = this; this.age = age; console.log(this) // Person &#123;age: 26&#125; setTimeout(function growUp() &#123; console.log(this); // window _this.age++; &#125;, 1000);&#125;var p = new Person(26); 箭头函数 个人理解：因为箭头函数没有自己的作用域，所以它在定义时就挂载了Person之上了。 123456789function Person(age) &#123; this.age = age; setTimeout(()=&gt; &#123; console.log(this); // Person this.age++; &#125;, 1000); console.log(this.age);&#125;var p = new Person(26); 返回值只有多行才需要返回值，一行则不需要 1let c = (a,b) =&gt; a+b 无arguments但有 123456function foo(n) &#123; var f = (...args) =&gt; args[0]+args.length; return f(n); &#125;foo(1); // 1 异步了解JavaScript的异步吗？ 回调函数 事件监听 发布/订阅 Promises对象 setTimeOut ajax 了解 Promise 吗？ 简要地描述了一下 resolve、reject 函数和 then 方法 Promise 是 ES6 的新特性，可以解决ES6新特性的问题。Promise构造函数接受一个函数作为参数，该函数包含两个参数：resolve 和 reject resolve: 如果异步操作成功，调用resolve，状态从pending 变为 resolved reject: 如果异步操作失败，调用reject，状态从pending 变为 rejected then: 返回一个新的Promise对象，因此可以采用链式写法 数组数组的方法有哪些？ pop() push() shift() unshift() slice() splice() join() 字符串 split() // 第一个参数：以什么分割， 第二个参数：设定返回的数组长度 数组的深拷贝 用push 用slice 12345var arr = [1,2,3,4,5]var arr2 = arr.slice(0)arr[2] = 5console.log(arr)console.log(arr2) JSON.stringify和JSON.parse转换该方法的缺点：非标准Json格式无法拷贝以及兼容性问题 判断数组的方法12345function isArray(o)&#123; if(Array.isArray(o) == true || Object.prototype.toString.call(o) == '[Object Array]')&#123; return true; &#125;&#125; 窗口位置获取元素以下信息，可以参考 offset系列 client系列 scroll系列 offsetWidth clientWidth scrollWidth offsetHeight clientHeight scrollHeight offsetLeft clientLeft scrollLeft offsetTop clientTop scrollTop width: document.body.clientWidth height: document.body.clientHeight 给定一个元素获取它相对于视图窗口的坐标1234567891011调用 box.getBoundingClientRect() 返回&#123; width: 122, height: 122, top: 30, left: 38, bottom: 152, right: 160, x: 38, y: 30&#125; 因此坐标可以从中获取 参考：JavaScript获取窗口位置和元素坐标 ES6ES6新特性，变化 对ES6新特性看法：这些特性可以使写出的代码更加简洁。块级作用域的出现 ，使变量的命名更加安全和规范。新增的模块特性使语言本身能够实现静态化模块依赖，相比于使用requireJS等动态模块来说有更高的效率。只是从现有的规范的模块移植到ES6原生的模块还需要借助模块转换 工具（或者手动更改模块的写法） let的作用域：变量只有在let的作用块有效 和const var:所在函数作用域 变量提升 let:所在作用快 不会代码提升 数组的解构 对象的解构：从数组或对象中提取值，对它们进行赋值 对象的扩展 ：proto Object.setPrototypeOf(object,prototype) Object.getPrototypeOf() Set数组：成员没有重复值 Map 键值对 函数默认值 rest参数 箭头函数：简化了写法；this指向所指对象 ；不能使用argument;不能使用call apply bind for..of 循环 class 对象 Promise 是异步编程的一种解决方案 Module：import export 模块管理 CommonJS 为同步，AMD 为异步。 CommonJS 是一中规范，NodeJS中所采用的规范。 ES6 标准为JavaScript新语法，我们不需要做引入。 CommonJS 和 AMD 为运行时加载，而 ES6 为编译时加载。 参考: 前端模块化 函数节流和函数反抖函数防抖（debounce） 当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间 1234567891011function _debounce(fn,wait) &#123; var timer = null; return function()&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; fn() &#125;,wait) &#125;&#125;window.onscroll = _debounce(_log,500) 函数节流（throttle） 预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期 12345678910111213141516171819202122232425function _throttle(fn,wait,time)&#123; var previous = null; //记录上一次运行的时间 var timer = null; return function()&#123; var now = new Date(); if(!previous) previous = now; //当上一次执行的时间与当前的时间差大于设置的执行间隔时长的话，就主动执行一次 if(now - previous &gt; time)&#123; clearTimeout(timer); fn(); previous = now;// 执行函数后，马上记录当前时间 &#125;else&#123; clearTimeout(timer); timer = setTimeout(function()&#123; fn(); &#125;,wait); &#125; &#125;&#125;function _log()&#123; console.log(1)&#125;window.onscroll = _debounce(_log,500,2000) 参考: 函数节流与函数防抖 resize和scroll事件的性能优化1234567window.addEventListener('resize', () =&gt; &#123; if(this.timeout) clearTimeout(this.timeout) this.timeout = setTimeout(() =&gt; &#123; console.log(11); &#125;, 1000);&#125;) 正则表达式 字符 等同于 描述 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [ \t\n\x0B\f\r] 空白字符 \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母) \W [^a-zA-Z_0-9] 非单词字符 代码 类型 描述 ? 软性量词 出现零次或一次 * 软性量词 出现零次或多次(任意次) + 软性量词 出现一次或多次（至道一次） {n} 硬性量词 对应零次或者n次 {n,m} 软性量词 至少出现n次但不超过m次 {n,} 软性量词 至少出现n次(+的升级版) 贪婪匹配 和 非贪婪匹配12345源字符串：aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc正则表达式一：&lt;div&gt;.*&lt;/div&gt;匹配结果一：&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;正则表达式二：&lt;div&gt;.*?&lt;/div&gt;匹配结果二：&lt;div&gt;test1&lt;/div&gt;（这里指的是一次匹配结果，所以没包括&lt;div&gt;test2&lt;/div&gt;） 参考:正则基础之——贪婪与非贪婪模式 全文单词首字母大写1234let a = "i am elle dsa jdfkhdsjghdf"let d = a.replace(/\b([a-z])([a-z]*)\b/ig,(str,$1,$2)=&gt;&#123; return $1.toUpperCase()+$2.toLowerCase()&#125;) 写一个 function，清除字符串前后的空格。（兼容所有浏览器）使用自带接口 trim()，考虑兼容性： 123456789if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, "").replace(/\s+$/,""); &#125;&#125;// test the functionvar str = " \t\n test string ".trim();alert(str == "test string"); // alerts "true" 把 aa_bb_cc 变为 aaBbCc方法一：正则:注意正则表达式中加不加括号的区别1234567let str = "aa_bb_cc";let newStr = str.replace(/_[a-z]/g, (str, index, allStr) =&gt; &#123; return str[1].toUpperCase();&#125;);console.log(newStr); 方法二：采用正则12345678910let reg = /([a-z])([a-z]*)_?/gi;let newStr = "aa_bb_cc".replace(reg, (str, p1, p2) =&gt; &#123; return p1.toUpperCase() + p2;&#125;);let newStr1 = newStr.replace(/^(\w)(\w+)$/, (str, p1, p2) =&gt; &#123; return p1.toLowerCase() + p2;&#125;);console.log(newStr1); 方法三：采用数组分割123456789function combo(msg) &#123; var arr = msg.split("-"); for (var i = 1; i &lt; arr.length; i++) &#123; arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1, arr[i].length - 1); &#125; msg = arr.join(""); return msg;&#125; var numberArray = [3,6,2,4,1,5]; 实现对该数组的倒排，输出[5,1,4,2,6,3];实现对该数组的降序排列，输出[6,5,4,3,2,1]12345678910111213// 倒排numberArray.reverse();// 降序numberArray.sort(function(a, b) &#123; if (a &gt; b) &#123; return -1; &#125; else if (a &lt; b) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;); 输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2017 年 9 月 13 日，则输出 2017-09-131234567891011var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? '0' + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? '0' + day : day;alert(year + '-' + month + '-' + day); 将字符串”{$id}{$name}”中的{$id}替换成 10，{$name}替换成 Tony （使用正则表达式）12”&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;”.replace(/&#123;\$id&#125;/g, ’10’).replace(/&#123;\$name&#125;/g, ‘Tony’); 写一个函数，实现{}括号里面的替换 当正则表达式里有字符串时，采用new RegExp的方法 12345678910function temp(str,obj) &#123; let re,newStr=str; Object.keys(obj).forEach(it =&gt; &#123; re = new RegExp(`&#123;($&#123;it&#125;)&#125;`,'g') str = str.replace(re,obj[it]) &#125;); return str;&#125;let a = temp('我的名字是&#123;name&#125;,我在&#123;address&#125;',&#123;name:'abigale',address:'广东深圳'&#125;) 兼容性 JavaScript兼容性问题 标准的事件绑定中绑定事件的方法函数为 addEventListener,而IE使用的是attachEvent 事件处理中非常有用的event属性获得亦不相同，获得目标元素ie为e.srcElement 标准浏览器为e.target 在ie中是不能操作tr的innerHtml的 ie日期函数处理与其它浏览器不大一致，比如： var year= new Date().getYear(); 在IE中会获得当前年，但是在firefox中则会获得当前年与1900的差值。 获得DOM节点的方法有所差异，其获得子节点方法不一致。IE:parentElement.children;Firefox:parentNode.childNodes 当html中节点缺失时，IE和Firefox对parentNode的解释不同。例如:&lt;form&gt; &lt;table&gt; &lt;input/&gt; &lt;/table&gt; &lt;/form&gt;IE：input.parentNode的值为空节点 Firefox：input.parentNode的值为form 解决方法：Firefox中节点没有removeNode方法，必须使用如下方法 node.parentNode.removeChild(node) 关于AJAX的实现上亦有所不同； 解决浏览器兼容性一些常用的库 normalize.css ： 解决CSS兼容问题 excanvas.js : 解决IE6-IE8不能采用canvas问题 html5shiv.js ： 解决IE6-IE8不能使用html5问题 respond.js ： 解决响应式布局问题 参考:解决浏览器兼容性一些常用的库 其他原生 js 怎么获取某个类名的所有元素 document.querySelectorAll() document.getElementByClassName() querySelector()返回文档中匹配指定 CSS 选择器的一个元素,如 document.querySelector(‘p’) document.querySelector(‘.aa’) document.querySelector(‘#aa’)]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise 异步请求方法]]></title>
    <url>%2F2018%2F05%2F23%2FPromise%2F</url>
    <content type="text"><![CDATA[关于 promise 异步请求方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function GET(url) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr; if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('GET', url, true) xhr.onreadystatechange = function (e) &#123; if (xhr.readyState == 4) &#123; if (this.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125;function postJSON(url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; let xhr; if (window.XMLHttpRequest) &#123; //非IE6 xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open("POST", url, true) xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); xhr.onreadystatechange = function () &#123; if (this.readyState === 4) &#123; if (this.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125;let url = 'https://api.github.com/'GET(url).then(res =&gt; &#123; console.log(res);&#125;).catch(error =&gt; &#123; console.error(error);&#125;) NodeJS Promise 替换 callback hell1234567891011121314151617181920212223242526272829303132333435var fs = require("fs");var path = require('path');let ReadFile = (fileName) =&gt; &#123; return new Promise( (resolve, reject) =&gt; &#123; fs.readFile(path.join(__dirname, fileName), "utf8", function (err, content) &#123; if (err) &#123; reject(err); //异常情况 &#125; else &#123; //正常情况 resolve(content); &#125; &#125;) &#125; )&#125;let WriteFile = (fileName, data) =&gt; &#123; return new Promise( (resolve, reject) =&gt; &#123; fs.readFile(path.join(__dirname, fileName), data, function (err) &#123; if (err) &#123; reject(err); //异常情况 &#125; else &#123; //正常情况 resolve('succesas'); &#125; &#125;) &#125; )&#125;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对浏览器做一些缓存]]></title>
    <url>%2F2018%2F04%2F17%2Fcache%2F</url>
    <content type="text"><![CDATA[面对浏览器，我们经常需要考虑一些性能的问题，除了让用户提高带宽，我们还需要通过缓存一些文件来提高用户体验。浏览器的缓存即是HTTP缓存，我们打开浏览器时总需要与远程服务器做交互，如果服务器允许的话，浏览器首次访问网站时会把成功的请求结果拦截下来并存储在内存或硬盘上，以便下次访问时快速获取。零零散散看过许多HTTP缓存的文章，所以这次想梳理一下脉络和自己动手模拟一下服务器看看我们可以如何指控浏览器缓存我们的文件。 DEMO学习过程中做了一个小demo模拟缓存过程，可以在https://github.com/abigaleypc/express-cache.git中查看源码。 强缓存 与 协商缓存HTTP缓存可以分为强缓存 与 协商缓存两大类。强缓存是当我们发起一个HTTP请求时，前端不会与服务器做交互，而是根据上一次设置的缓存期限，未过期时则不再向后端做请求，即使文件已经被更新了我们也无法获取。而协商缓存则需要与服务器做一个交互，当服务器告诉我们上次的缓存并未做修改时，后端则不返回我们需要的文件，否则返回最新文件。 强缓存强缓存包含Expires 与 cache-control Expires表示存在时间，允许客户端在这个时间之前不去检查（发请求），例如：Expires: Wed, 21 Oct 2015 07:28:00 GMT 可采用两种方法对Expires进行设置： 页面标签中设置 1&lt; META HTTP-EQUIV="Expires" VALUE="May 31,2001 13:30:15" &gt; 后端设置 1Response.Expires=时间（单位：分）来启用缓存。 // 另一种方式 Response.AddHeader("expires","utc时刻") 以上时间表示消息发送的时间，时间的描述格式由rfc822定义。例如,Web服务器告诉浏览器在2018-04-28 03:30:01这个时间点之前，可以使用缓存文件。发送请求的时间是2018-04-28 03:25:01，即缓存5分钟。 理解cache-control强缓存 - 体验max-age“max-age”指令指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）。如果还有一个 设置了 “max-age” 或者 “s-max-age” 指令的Cache-Control响应头，那么 Expires 头就会被忽略。 下面做一个测试max-age的实验，打开GitHub的项目并npm start ，测试之前请打开控制台，将浏览器控制台中的Disable cache关闭。如下图 Step1: 在入口文件app.js中设置最大缓存时间，如下： 123456app.use( "/public", express.static("public", &#123; maxAge: "1d" &#125;)); Step2: 将/public下的静态文件最大缓存时间设为一天，现在在/public下的main.js写了一段更新页面文本的代码 1234window.onload = function() &#123; let name = document.getElementById("name"); name.innerText = "abigale";&#125;; Step3: 第一次打开浏览器并打开控制台，点击max-age菜单，采用max-age做缓存：浏览器查找缓存文件的顺序为 memory - disk - 网络 Step4: 刷新页面：缓存优先从memory查找，如查找得到则采用memory中文件 Step5: 重新打开页面：memory若无缓存，则从disk查找 Step6: 修改/public/main.js 1234window.onload = function() &#123; let name = document.getElementById("name"); name.innerText = "AbigaleYu";&#125;; 无论是刷新页面访问还是重新打开页面访问，结果与Step4 Step5一样，name并没有更新为AbigaleYu。这是因为强缓存在缓存时间内并不会去获取新文件，而是采用缓存文件 该缓存策略弊端： 当设定时间内更新文件了，浏览器并不知道。其他valuecache-control 下还有其他几个常用的value no-cache： 表示每次请求都需要与服务器确认一次，这种情况一般带有ETag，当服务器端验证无修改时，则从缓存中取文件，服务器无需返回文件。 no-store: 表示无论如何都不允许客户端做缓存，每次凑需要做一次完整的请求和完整的响应。 public：如果响应被标记为“public”，则即使它有关联的 HTTP 身份验证，甚至响应状态代码通常无法缓存，也可以缓存响应。大多数情况下，“public”不是必需的，因为明确的缓存信息（例如“max-age”）已表示响应是可以缓存的。我们有时可以在memory,disk,路由等找到缓存就是因为这是public的设置 private：不允许任何中间缓存对其进行缓存，只能最终用户做缓存 举一些例子 缓存设置 表现 max-age=86400 浏览器以及任何中间缓存均可将响应（如果是“public”响应）缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。 max-age=86400 浏览器以及任何中间缓存均可将响应（如果是“public”响应）缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。 private, max-age=600 客户端的浏览器只能将响应缓存最长 10 分钟（60 秒 x 10 分钟）。 no-store 不允许缓存响应，每次请求都必须完整获取。 引申问题：from memory cache 与 from disk cache 的区别浏览器访问页面时，查找静态文件首先会从缓存中读取，缓存分为两种，内存缓存与硬盘缓存。查找文件的顺序为：memory -&gt; disk -&gt; 服务器。内存缓存是在kill进程时删除，即关闭浏览器时内存缓存消失，而硬盘缓存则是即使关闭浏览器也仍然存在。当我们首次访问页面，需要从服务器获取资源，将可缓存的文件缓存在内存与硬盘，当刷新页面时(这种情况没有关闭浏览器)则从内存缓存中读取，我们可以在上面的截图看到from memory cache的所需要的时间为0，这是最快的读取文件方式，当我们重新开一个页面时，也就是已经kill这个进程，内存缓存已经消失了，这时候就从硬件缓存获取，而当我们手动在浏览器清除缓存时，下次访问就只能再去服务器拉取文件了。但有一点可以从上面图中看到，并不是从硬盘获取缓存的时间一定比从网络获取的时间短，示例中的时间是更长的，这取决于网络状态和文件大小等因素，从缓存获取有利有弊，当网络较差或者文件较大时，从硬盘缓存获取可以给用户较好的体验。 协商缓存Last-Modified 与 If-Modify-since Last-Modified 标示这个响应资源的最后修改时间。web 服务器在响应请求时，告诉浏览器资源的最后修改时间 If-Modify-since 再次向服务器请求时带上，如果资源已修改，返回 HTTP 200，未被修改，返回 HTTP 304 DEMO : 依然是GitHub的源码。可切换到菜单 Last Modified / If-Modified-Since 查看 Step1: 在app.js入口文件中，我们通过将 Last-Modified 的头设置为操作系统上该文件的上次修改日期来控制缓存 1234567app.use( "/lastModified", express.static("public/lastModified", &#123; lastModified: true, setHeaders: setCustomCacheControl &#125;)); Step2: 在路径为./public/lastModified/main.js的文件中，读取文件response header中的 Last-modified 展示出来 1234window.onload = function() &#123; let time = document.getElementById("time"); time.innerText = document.lastModified;&#125;; Step3: 点击菜单Last Modified / If-Modified-Since，第一次请求状态码是意料中的200，但可以看到响应头response header多了Last-modified 记录我们最后修改文件的时间 Step4: 再次刷新页面时，状态码更新为304(Not Modified)，但不同与max-age，此处的304虽然是文件并未被修改，但依然需要相似的请求时间，这是因为协商缓存需要向服务器咨询文件是否被更新，而且可以看到该请求中request header 多了 If-Modified-Since 字段，这就是告诉浏览器上次文件的修改时间。可以看到上次修改时间 If-Modified-Since 与 响应头 response header 中 Last-modified 是一致的，因此返回文件未被修改。 Step5: 修改main.js中的内容，并刷新页面，这次可以看到main.js的请求不是返回304，而是200，展开main.js请求，也可以看到request header 中上次修改时间 If-Modified-Since 与 响应头 response header 中 Last-modified 是不一致的，因为我们需要获取到最新文件而不是使用缓存文件。 ETag 和 If-None-Match ETag 告诉浏览器当前资源在服务器的唯一标识 If-None-Match 再次向服务器请求时带上，如果资源已修改，返回 HTTP 200,未被修改，返回 HTTP 304 总结浏览器获取文件的过程如下：]]></content>
      <categories>
        <category>Front-End</category>
        <category>http</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>cache</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扮演服务层角色 -- NodeJs]]></title>
    <url>%2F2018%2F03%2F14%2Fmusicer-backend%2F</url>
    <content type="text"><![CDATA[续上一篇搭建音乐播放器桌面应用–前端篇后，这次讲述给界面提供数据包的后端扮演者–Node接入层。 Node在项目中扮演的是后端，但准确地说Node这并不是后端的角色，真正后端角色是豆瓣FM暴露的API。如下图 中间这一服务层即是本文的重点：对接口的挖取与封装。豆瓣FM官方并没对外提供API手册，尽管豆瓣提供了开放平台, 但与我们登录官方网站进行授权与操作走的并不是同一通道。开放平台开放的类似于第三方登录 给开发者一个新的API Key，有了这个key而允许了我们对指定的功能进行指定的操作。这对于开发者是很受限的，因此我们需要采取各种可能的手段抓包，分析整合，整理出我们真正需要的接口。 上图中豆瓣FMAPI来源：https://douban.fm。 源码Musicer 三端如何分工 前端：界面布局，数据渲染 服务层(接入层)：接口封装，功能拆分 后端(豆瓣FM接口)：提供原始数据包 端与端之间如何交互交互可分为前端与服务层的交互，以及服务层与后端的交互。 前端与服务层在这两者之间我们需要思考几个问题 如何设计接口 接口应遵循哪些规范 提供哪些类型的接口 如何设计接口我们采用RESTful API，它是目前比较成熟的一套API设计理论，事实上在工作中我接触到的后端接口也均是RESTful设计的API。RESTful API是面向资源的API设计架构，资源即为可供我们操作的数据群。结合我们这个项目，资源即为用户登录而获得用户的token，个人信息，爱心歌曲，歌曲歌词等。到此我们可以确定我们的API一半身形：/aaa 或者 /bbb ,这aaa 和 bbb 指的是资源位置。 接口遵循的规范： 路径：根据功能划分，播放器这个项目中我们分为两大部分功能，用户管理和歌曲管理，因此路径可能长这样： 12345678用户管理:/user/login: 登录/user/basic: 获取个人基本信息歌曲管理/song/next 下一首/song/like 点赞歌曲/song/lyric 获取歌词 方法： 这个项目中我们只用到三种方法，GET，POST GET：用于资源获取，不做增删改查，如切换到粤语歌曲。 POST：用于对资源修改或获取一些重要信息。如点赞歌曲，记录会存在个人账号里面；登录时获取token信息。 返回格式： 12345678&#123; &lt;!-- 失败：0 成功：1 --&gt; "code": 1, "msg": "success", // failed "data" : &#123; &#125; &#125; 一个登陆API示例： 123456789101112131415161718192021登录- url: http://xxxxx/user/login- param: &#123; username:13798994068, password:123456c&#125;- method: get- return: &#123; &lt;!-- 失败：0 成功：1 --&gt; "code": 1, "msg": "success", // failed "data" : &#123; "access_token": "25a64943770f2dbca55d46995", "douban_user_name": "abigaleyu", "douban_user_id": "1688842", "expires_in": 7775999, "refresh_token": "5f2388c502a9a4f0799f2f9" &#125; &#125; 服务层与豆瓣FM的交互这一交互我们同样需要思考几个问题： 如何从豆瓣FM获取登录信息 个人账号下操作歌曲 如何根据接口规范封装接口 路径从入口文件index.js中我们可以看到： 12345const PORT = process.env.PORT || 8082;const server = express();server.use('/user', user);server.use('/song', song); 如何从豆瓣FM获取登录信息从豆瓣FM获取登录信息占据了这层面工作量的70%，原因在与豆瓣FM的登陆是会重定向到豆瓣官网的登陆，需要多次重定向并且在不同的URL中读取header里的cookie并存下来，召集我们所需要的几个k-v之后才可以为所欲为，比如听自己喜欢的歌呀，点赞喜欢的歌曲呀~ 文件 src/routes/user.js 中我们可以看到存在这一逻辑： /login —&gt;/basic?username=xxx&amp;password=xxx&amp;token=xxx –&gt; getUserAc() –&gt; serveceAcount() –&gt; getDouBanFm() –&gt; getUserBid() –&gt; getUserAc() 这就是为了从多个重定向的header里面挖取到我们需要的cookie /login获取到到access_token，官方请求如下： 1234567891011121314## 登录- url: https://www.douban.com/service/auth2/token- param: &#123; username: username, password: password &#125;- method: post- return: &#123; access_token: '208e18axxxxxxxxx78ebf00a1', douban_user_name: 'abigaleyu', douban_user_id: '168889042', expires_in: 7775999, refresh_token: 'd9243263xxxxxxxx22a0b7eea' &#125; 获取个人基本信息，headers中需要加上以上获取的有效token 1234567891011121314151617181920212223242526- url: https://accounts.douban.com/j/popup/login/basic- headers: &#123; Authorization: 'Bearer '+ token &#125;- param: &#123; source: fm referer: https://douban.fm/ ck: L-UM name: username password: password captcha_solution: null captcha_id: null &#125;- method: post- return: &#123; &lt;!-- 获取成功 --&gt; &#123; "status": "success", "message": "success", "description": "处理成功" &#125; &lt;!-- 获取失败 根据图片输入验证码再次请求 --&gt; "status": "failed", "message": "captcha_required", "description": "需要图形验证码" &#125; 我们可以从返回结果中拿到我们要的基本信息 我们要找的key-value就藏在截图部分，从cookie里劫持下来，存到本地，再看一个截图，状态码是200而不是3开头，是因为这个basic的请求中，Request Headers有一行：Referer:https://accounts.douban.com/popup/login?source=fm&amp;use_post_message ，有什么特殊的吗~可以看下下面的截图 关注Response Headers 里的Location，我们正需要从它调整的链接中去找下一个值。也正式因为它在Response中而非Request中，所以Status Code 为3开头。 具体获取过程可以查看src/routes/user.js，总之我们最终需要集齐token,bid,dbcl12,ck这几个值，以下请求是我在登录状态下点击下一首歌曲浏览器显示的请求头，我们获取到的值就派上用场了~ 接口封装我们根据约定好的规范：方法，返回结果等进行文档梳理 登录态:我们分为初次登录和采用token登录 初次登录：即无token或token已过期 123456789101112131415161718## 登录- url: http://localhost:8082/user/login- param: &#123; username: username, password: password &#125;- method: post- return: &#123; code: 1, msg: 'success', data: &#123; access_token: '208e18axxxxxxxxx78ebf00a1', douban_user_name: 'abigaleyu', douban_user_id: '168889042', expires_in: 7775999, refresh_token: 'd9243263xxxxxxxx22a0b7eea' &#125; &#125; 采用token登录：token未过期的条件下，我们可以重复利用它 12345678910111213141516171819202122- url: http://localhost:8082/user/loginByToken- param: &#123; username:13798994068, token:xxxxxxx&#125;- method: get- return: &#123; &lt;!-- 失败：0 成功：1 --&gt; &quot;code&quot;: 1, &quot;msg&quot;: &quot;success&quot;, // failed &quot;data&quot; : &#123; &lt;!-- 成功：1 --&gt; &quot;access_token&quot;: &quot;25a64943770f2dbca55d46995&quot;, &quot;douban_user_name&quot;: &quot;abigaleyu&quot;, &quot;douban_user_id&quot;: &quot;1688842&quot;, &quot;expires_in&quot;: 7775999, &quot;refresh_token&quot;: &quot;5f2388c502a9a4f0799f2f9&quot; &#125; &lt;!-- 失败 0 --&gt; &quot;code&quot;: -1, &quot;msg&quot;: &quot;failed&quot; &#125; 我在Node接入层与豆瓣FM的交互中重点解释了登录逻辑，关于歌曲的获取，切换等方式可以参考登录API获取的步骤，它们会比登录简单的哟~ 总结一下，Node实现的这一层为接入层，负责再次封装接口以及输出，也为我们做一些安全相关信息的保护，假如你需要做一些服务器同构渲染，很建议加入这样一层接入层]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配方案]]></title>
    <url>%2F2018%2F02%2F24%2Fmobile-adaptive%2F</url>
    <content type="text"><![CDATA[关于移动端适配方案 方案一：根据设计稿切分单位像素js脚本控制根元素字体。 12let html = document.getElementsByTagName('html')[0];html.style.fontSize = (window.innerWidth/750) +'px'; 以上750是根据设计稿尺寸设定的，这是为了方便CSS设定尺寸。 原理：将屏幕尺寸宽(window.innerWidth)分成750份，而CSS中我们可以根据每一份设对应的Rem值。12345.header &#123; font-size: 35rem; width: 750rem; height: 127rem;&#125; 以上对应的即是 12345.header &#123; font-size: 35px; width: 750px; height: 127px;&#125; 未完待续…]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建音乐播放器桌面应用--前端篇]]></title>
    <url>%2F2018%2F02%2F22%2Fmusicer%2F</url>
    <content type="text"><![CDATA[强大的JavaScript似乎无所不能了，除了PC端的单页面实现，可以用RN或weex完成兼容Android端和iOS端的APP，也可以用Electron搭建兼容Mac或Windows的桌面应用了。 这篇文章主要讲一个播放器的从零开始的实现过程，包括前后端的架构和选型分析；采用前后端分离，前后端如何分工合作；数据的获取与存储；如何抓包。 源码Musicer 最终效果 前端架构 React: 基于虚拟DOM实现单向响应式数据流的UI框架。 Redux: 提供单向，可预测的数据流。 Electron: 使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架。 选型React 基于v-dom的UI框架: 采用virtual dom render + diff进行必要的DOM渲染。这样的好处是我们可以采用一种比重置innerHtml 更高效的方法更新DOM元素。在过往我们写的DOM元素是需要调出DOM然后再对它操作，因此导致页面reflow或repaint,而react是所有元素置于v-dom，即完完全全在JavaScript中曲操作DOM，这样开销就小了很多。 高度组件化：虽然前端应用复杂度越来越大，我们传统的做法是多个HTML和js文件，而新时代赋予了一种新兴的科技即组件。我们可以将通用或不通用的模块分成一个个组件，分别放在components和containers中，结合ES6或CommonJS的模块加载方案实现组件加载。 Electron 跨平台: 兼容Mac, Windows 和 Linux 浏览器兼容: PC端的前端攻城狮经常需要考虑浏览器的兼容性，而当我们把呈现在页面上的内容转移到应用上时，我们可以直接根据Chrome浏览器编程。 快速上手: 这可以直接省去大量学习成本，只要搭建好基础框架，就可以像写页面一样去写应用。 Redux 优秀之处: Redux是一个管理全局state的容器，它的优秀之处在于将所有状态从所有模块组件中抽身而出的状态集合，可以理解为每个组件中的一个变量或一个对象，如果没有Redux，我们可能需要通过React中state,props去层层传值，但redux提供给我们的是全局的状态，所有状态集合store,通知作用的action和执行官reducer。这样很好地减少数据耦合，我们可以站在一个地方观览所有数据。 可恨之处: 每次添加新状态都需要在store,action,reducer添加新行为，这让代码看起来非常冗余，似乎写了特别多重复性代码，如果追求代码简洁，redux会让你泪奔~~o(&gt;_&lt;)o ~~ 前端实现方案思路系统中的组件 以上是播放器的组件结构，从Root入口开始。 Main：处理初始化状态，如登录状态 Home: 界面翻转切换逻辑，歌曲切换逻辑 Login,Account,Share,Lyric：提供切换界面 决定采用React就是看中其高度组件化的优势，这些组件从开始至今被更改了好几次，累加简化再累加再简化，抽离成目前的状态。我们本来可以在Home中处理所有逻辑，再将状态一一扔给action去通知再处理，而后来我在Home之前加入一个包围一个Main,这样做的目的是将初始化和进行中分成两个时间维度，我们可以在开始之前先预知这一次用户的状态，再呈现处理。 后面的四小组件也是功能组件，各司其职，如Login是用户登录界面，我们只在里面处理登录更改事物，再将最后的状态通知到action再做处理；同理Lyric是歌词组件，获取当前歌曲再做展示。可在项目中/public/Components查看各个组件 Main组件中的初始化首先Main组件会查看缓存中是否有用户token信息存在，若无则将登录状态设为未登录；若有，则在前端获取信息查看信息是否过期，获取的信息如下： 1234567"data": &#123; "access_token": "25a64943770fca55d46995", "douban_user_name": "abigaleyu", "douban_user_id": "1688842", "expires_in": 7775999, "refresh_token": "5f2388c502a0799f2f9" &#125; 以上expires_in即为从获取信息时间的7775999秒后将会过期，因此我们需要将当下时间和有效期做下对比。若已过期，将缓存信息清除后将登录状态设为未登录，否则则通过登录，然后将本次登录状态设为true，在之后如需获取个人信息，点赞歌词等个人相关操作时，我们将需要用到该token(即个人身份令牌)去操作。 登录逻辑 这是当用户切入登录界面时，我们已在Main获取到登录状态，它将通知到全局，而我们又可以在全局获取到该状态，当为true时，则直接用token去访问后端要些个人信息（用户账号，用户ID，用户头像等），当登录状态为false时，则进入以上流程，用户凭输入的用户名和密码去请求API（界面出现用户名和密码的输入框），通过时则返回token，不通过时会出现多种情况：登录多次错误需要验证码；账号错误；密码错误；账号不存在等，我们这里简化成两种状态：需要验证码（界面会多出验证码输入框和验证码图片）和 其他不需要验证码的情况。当再次输入正确或验证码也通过时，则获取到token。注意以上流程我们只有一个目的：获取token。这是一个身份令牌，我们只有拥有它就有权限去干个人相关的事情。至于通过就获取到个人信息 ，我们和用户操作归到一起，都是只拿token去操作。 获取个人信息这便是拿到token之后的事情，拿到token就意味着已登录完毕，如没获取到token，会返回到登录界面去要求用户登录。当我们手持token时，先会在前端验证token的有效期，这样做的意义是避免网络开销，前后端验证开销，如果不这么做，当我们拿着已经过期的token去向后端要个人信息时，后端返回告诉我们token无效的，前端再告诉用户需要重新登录。因此这一步会显得很有必要。若前端验证为有效期内的token时，这才向后端获取有效的个人信息，当然，这个token后端也会做一次判断，如果前端是乱传过去的呢~ 快速创建示例仓库并安装运行 克隆库git clone https://github.com/electron/electron-quick-start 进入路径cd electron-quick-start 安装依赖库并启动npm install &amp;&amp; npm start 启动入口文件在package.json中可以看到启动的入口文件为./public/main.js 代码均为文件节选代码块，详见示例代码 123456789101112131415161718192021let mainWindow/** * createWindow 创建前端界面窗口。 */function createWindow() &#123; mainWindow = new BrowserWindow(&#123; width: 195, height: 230, frame: false,transparent: true&#125;) mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, 'index.html'), protocol: 'file:', slashes: true &#125;))&#125;app.on('ready', createWindow)const PORT = process.env.PORT || 8082;const server = express();server.listen(PORT, () =&gt; &#123; console.log(`The server has been set up at 0.0.0.0:$&#123;PORT&#125;`);&#125;); 入口文件主要实现 窗口的创建，关闭等事件 启动后端服务 前端窗口我们重点关注窗口内业务代码实现，至于窗口如何与PC交互，Electron已经帮我们解决了。 以上示例中 BrowserWindow 类主要定义窗口的基本元素，width和height定义宽高。frame定义是否需要边框。transparent定义背景是否透明。 示例中 mainWindow.loadURL方法定义入口UI模板index.html Electron框架结合ReactElectron提供平台框架，相当于浏览器。添加react库 安装React npm install react 新建脚本entry.js,实现前端脚本逻辑。这里我们使用webpack打包并嵌入入口UI模板index.html 数据存储前端跟后端不一样，不能有DB的存在。但我们可以造伪DB，可以用cookie，localStorage和sessionStorage，或者将数据存在本地文件夹，本例中采用localStorage 踩过的小坑 父子组件通信：父组件向子组件通信时，可以通过子组件属性传递，而子组件向父组件传递时，可调用父级方法。 组件中获取video属性：嵌入的音乐播放器video，但比如暂停，获取歌曲长度等，在虚拟DOM都不可直接获取，但可以通过video的各个方法，如onTimeUpdate，根据时间的变化执行函数去获取当前位置。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>React</tag>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript的使用场景]]></title>
    <url>%2F2018%2F01%2F22%2FtypescriptSence%2F</url>
    <content type="text"><![CDATA[React 接口定义 使用interface 1234interface IMProps &#123; num: number, str: string&#125; 类的定义 使用泛型 123class MyClass extends React.component&lt;Props:IMProps, State:&#123;&#125;&gt;&#123;&#125; 类的构造函数 需加参数 123constructor(props: IMProps) &#123; &#125; 变量修饰符 以下不参与生命周期的流程 123class MyClass extends React.component&lt;Props:IMProps, State:&#123;&#125;&gt;&#123; private value:number = 1;&#125; 函数的接口 写法 123456789101112131415function getNum (num1:number, num2:number): number &#123;&#125;getNum = (num1:number, num2:number): number =&gt;&#123;&#125;let getNum: (num1:number, num2:number) =&gt; number = function(num1:number, num2:number): number &#123; &#125;// render 中 render函数public render(): JSX.Element &#123;&#125; 类的接口写法 12345678interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; Node 定义函数 注释 1234567/** * 服务 * @param &#123;optionType&#125; [option = &#123;xx:xx, xx:xx&#125;] * /public server(option: optionType) &#123; &#125;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初涉Charles]]></title>
    <url>%2F2017%2F10%2F16%2FCharles-study%2F</url>
    <content type="text"><![CDATA[了解Charles Charles是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当浏览器连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。 Charles是一个简单的基于HTTP协议传输的调试工具，可以帮助开发人员分析数据和加快调试BUG的效率。 本地映射tools –&gt; Map Local(快捷键 alt+command+L) –&gt; 映射设置如下图： 接入手机 打开命令行工具，采用ipconfig(Windows) 或 ifconfig(Mac) 查看本地IP 在 Charles 中，proxy –&gt; proxy Setting –&gt; proxies –&gt; 查看 HTTP Proxy端口，如下图： 打开手机连上与PC端同一WiFi，然后进入该WiFi的高级设置。手机上设置如下： 指南http://timhordern.com/charles-proxy-tips/]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型上小心被共享]]></title>
    <url>%2F2017%2F09%2F18%2Fprototype-function-sharing%2F</url>
    <content type="text"><![CDATA[123456789101112function Person() &#123;&#125;Person.prototype.friends = ["abigale"]Person.prototype.sayFriends = function() &#123; console.log(this.friends)&#125;let p1 = new Person()let p2 = new Person()p1.friends.push('ypc')p2.sayFriends() // [ 'abigale', 'ypc' ] 我们在 实例 p1 上添加了一个朋友，但从 实例p2 打印出朋友名单却意外得出加在 p1 上的朋友，这是因为 （画重点） 包含引用类型值得原型属性会被所有实例共享 JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。 另一种情况，等同于上述 1234567891011121314151617function Person() &#123; this.friends = ['abigale']&#125;Person.prototype.sayFriends = function() &#123; console.log(this.friends)&#125;function SubPerson() &#123;&#125;SubPerson.prototype = new Person();let p1 = new SubPerson()let p2 = new SubPerson()p1.friends.push('ypc')p2.sayFriends() 第二种示例，其实就是SubPerson.prototype.friends 它是共享的 如果将上面数组类型改成基本类型就不会出现这种情况了，如Person.prototype.friends = &#39;abigale&#39;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化]]></title>
    <url>%2F2017%2F08%2F21%2FEF-module%2F</url>
    <content type="text"><![CDATA[简单说一下前端模块化标准的基础用法~~ CommonJSCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。示例： 123456// a.jsvar obj = &#123; name: 'John', age: 18&#125;module.exports = obj; 1234// b.jsvar obj = require('./a');obj.name; // John AMDAMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。 语法： define(id?, dependencies?, factory);，前两个参数可选 示例： 1234567define('objModule', ['jquery'], function($) &#123; // $ 是 jquery 模块的输出 $('body').text('hello world');&#125;);// 使用,相比起CommonJS多了回调函数require(['objModule'], function(myModule) &#123;&#125;); ES6新一代JavaScript标准 示例一： 123456// a.jsvar obj = &#123; name: 'John', age: 18&#125;export default obj; 1234// b.jsimport obj from './a';obj.name; // John 示例二： 123456// a.jsvar obj = &#123; name: 'John', age: 18&#125;exports.obj = obj; 123// b.jsimport &#123; obj &#125; from './a';obj.name; // John 其他 CommonJS为同步，AMD为异步。 CommonJS是一中规范，NodeJS中所采用的规范。 ES6 标准为JavaScript新语法，我们不需要做引入。 CommonJS 和 AMD 为运行时加载，而 ES6 为编译时加载。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序的登录态、身份验证和敏感信息获取]]></title>
    <url>%2F2017%2F08%2F11%2Fminiprograms-signin%2F</url>
    <content type="text"><![CDATA[微信小程序有一套严格且小复杂的登录方案，为了疏通整个登录流程，我花了好几天的时间画图与测试，终于开花结果喇~ 流程如下： 登录态的作用 检测登录是否过期 通过调用微信登陆接口获取登录凭证，进而获取敏感信息 步骤 微信小程序(前端，以下统称前端) wx.checkSession() 是每次进入微信小程序时最先调用的接口，因为微信小程序的登录具有时效性，该内置函数式为了检测登录是否过期了。 12345678wx.checkSession(&#123; success: function()&#123; // 登录态未过期，可进行我们所需要的业务 &#125;, fail: function()&#123; wx.login() // 登录态已过期，需重新登录 &#125;&#125;) 具体用法 如果我们是第一次登录，或者登录态已经过期，则前端调用 wx.login() ，该函数将返回一个用户凭证 code,如 {code:&#39;7rheuw93her0239urhf&#39;}。 12345wx.login(&#123; success: function(res) &#123; console.log(res.code); // '7rheuw93her0239urhf' &#125;&#125;); 我们需要自己启动一个后端，即流程图中的 第三方服务器 ，将以上获取到的 code 传至第三方服务器 前端代码示例： 12345678910111213141516wx.login(&#123; success: function (res) &#123; wx.request(&#123; url: 'https://XXXX.com:8080/api/authorization', // 这个接口写于后端，用于向微信服务器 换取 session_key 和 openId 的接口 data: &#123; code: res.code // 将wx.login()返回 code 传至第三方服务器 &#125;, header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; // 发送成功 &#125; &#125;) &#125;&#125;) 该接口 https://XXXX.com:8080/api/authorization 调用微信服务器接口 ‘jscode2session’获取用户唯一标识openid和会话密钥session_key 该接口调用微信服务器接口：https://api.weixin.qq.com/sns/jscode2session ，所需参数和返回字段如下： 请求所需字段 appid: 小程序的唯一标识 secret: 小程序的app secret js_code: 以上提到很多次的 code grant_type: 均为 authorization_code 返回字段 openid: 用户的唯一标识 session_key: 登录的会话密钥 expires_in: 有效时间 由于我测试的项目后端语言采用node实现，所以该文章所有后端代码均是node示例。 后端代码示例： 12345678910111213141516171819202122router.get('/authorization', function (req, res, next) &#123; // 获取session_key expires_in openid request.get(&#123; uri: 'https://api.weixin.qq.com/sns/jscode2session', json: true, qs: &#123; grant_type: 'authorization_code', appid: appId, secret: appSecret, js_code: req.query.code &#125; &#125;, (err, response, data) =&gt; &#123; if (response.statusCode === 200) &#123; data.openid // 用户唯一标识 data.session_key // 会话密钥 data.expires_in // 有效时间 &#125; else &#123; res.json(err) &#125; &#125;)&#125;) 生成第三方session，根据微信小程序官方的建议：用于第三方服务器和小程序之间做登录态校验，为了保证安全性，3rd_session应该满足： 足够长。建议有 2^128 组合 避免使用 srand(当前时间)，然后 rand() 的方法，而是采用操作系统提供的真正随机数机制 设置一定的有效时间 生成3rd_session的方法有很多种，我们暂且跳过这一步骤，就假设 3rd_session=&#39;6c22c620b4fJE2878fc8f10b5ba2ffe&#39; (当然3rd_session是数字开头不能作为变量名，代码中为 secret.SECRET)，根据 code 获取 session_key 和 openId ,再将它们存在内存中。以3rd_session为key，session_key 和 openId 为value存储。 我采用的方式是将 session_key 和 openId 写为json格式，再将该json格式转为string，假设转为string格式后为 &#39;{session_key:001, openId:002}&#39;，然后再将它作为value，3rd_session为key ，存入内存中。 将 3rd_session 返回给前端，前端需要将它存在storage，第三方服务器也需要将 {3rd_session:session_key+openid} 存在内存中。 如何存在内存？可以 npm install redis --save，然后const redis = require(&#39;redis&#39;); redisStore = redis.createClient();将其引入，Redis 是内存中的数据结构存储系统，我们可以将3rd_session存下来 最后封装好我们的第三方session之后，就这个3rd_session返回到前端 后端代码示例： 1234567891011121314151617181920212223242526272829303132router.get('/authorization', function (req, res, next) &#123; // 获取session_key expires_in openid request.get(&#123; uri: 'https://api.weixin.qq.com/sns/jscode2session', json: true, qs: &#123; grant_type: 'authorization_code', appid: appId, secret: appSecret, js_code: req.query.code &#125; &#125;, (err, response, data) =&gt; &#123; if (response.statusCode === 200) &#123; //TODO: 生成一个唯一字符串sessionid作为键，将openid和session_key作为值，存入redis，超时时间设置为2小时 let secretValue = &#123; openid: data.openid, session_key: data.session_key &#125; // 将&#123;secret.SECRET:JSON.stringify(secretValue)&#125; 存入内存中，过期时间设置为微信小程序接口返回给我们的有效时间 redisStore.set(secret.SECRET, JSON.stringify(secretValue), 'EX', data.expires_in); &#125; else &#123; res.json(err) &#125; &#125;) // 返回给前端 res.send(&#123; wxtoken: secret.SECRET &#125;)&#125;) 这时候我们前端已经收到 3rd_session，需要将它存在Storage中，采用微信小程序内置函数 wx.setStorage() 存储。 12345// 伪代码wx.setStorage(&#123; key:"3rd_session", data: 3rd_session&#125;) 至此，我们获取密钥生成 `3rd_session` 的过程就结束了。但有何用呢？`3rd_session` 是为了每次做请求时做用户验证，比如用户想做一些只有用户本人才能做的操作，不需要每次都去问微信服务端 `是本人才操作` 吗，在有效时间内我们问自己的服务端就行，这个有效时间微信服务端已返回，即 `expires_in` 。 接下来我们带上 `3rd_session` 去做一些只有本人才能做的操作，比如获取个人敏感信息。 获取用户信息，当只需要获取用户个人基本信息时，不需要与第三方服务器做交互，只需要调用如下接口： 1234567891011121314151617wx.getUserInfo(&#123; success: function(res) &#123; // 返回用户基本信息如下res &#125;&#125;)res:&#123; userInfo: '', nickName: 'Abigale', avatarUrl: 'https://xxx.com/xx.png', userInfo: '', gender: 2, province: '', city: '', country: '',&#125; 但当我们需要获取个人的敏感信息时，需要将请求参数 withCredentials 设为 true，默认该值为 false，该字段意为是否带上登录态信息 。 12345678910111213141516171819202122232425262728wx.getUserInfo(&#123; success: function(res) &#123; withCredentials: true, // 设为 true // 返回带敏感信息的个人信息如下res &#125; &#125;) res: &#123; errMsg: "getUserInfo:ok", rawData: "&#123;"nickName":"Abigale","gender":2,"language":"zh_CN"&#125;", userInfo: Object, signature: "xxxx", encryptedData: "xxx", errMsg: "getUserInfo:ok", userInfo: "", avatarUrl: "https://xxx.com/xx.png", iv: "re3dw", userInfo: &#123; nickName: 'Abigale', avatarUrl: 'https://xxx.com/xx.png', userInfo: '', gender: 2, province: '', city: '', country: '', &#125; &#125; 以上敏感信息加密算法可参考：[用户数据的签名验证和加密](https://mp.weixin.qq.com/debug/wxadoc/dev/api/signature.html) 前端带着以上个人敏感信息和 3rd_session 向第三方服务器发起请求，目的是解密获取个人敏感信息 首先第三方服务器根据 3rd_session ，在内存中取出 session_key，因内存中我们是采用 JSON.stringify(secretValue) 将session_key和 openid 存起来的，所以取出的时候我们可以采用 JSON.parse(secretValue)。 根据 config.appId , session_key , encryptedData , iv 对数据进行解密 敏感信息解密算法可参考：用户数据的签名验证和解密 解密后的信息如下 123456789101112131415&#123; "openId": "OPENID", "nickName": "NICKNAME", "gender": GENDER, "city": "CITY", "province": "PROVINCE", "country": "COUNTRY", "avatarUrl": "AVATARURL", "unionId": "UNIONID", "watermark": &#123; "appid":"APPID", "timestamp":TIMESTAMP &#125;&#125; 至此，获取敏感信息步骤也完成啦啦♪(^∇^*) 代码示例我所遇到的疑惑 为什么微信小程序已经有登录检测，过期时会弹出窗口让用户去点击”允许”去登录，为什么还是需要我们通过 wx.checkSession() 去检测是否登录过期进而去调用 wx.login() 呢？ 因为调用 wx.login() 是为了获取登录凭证，当这个登录凭证在有效期内，就不需要跑去微信服务器问本人登录是否过期了]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>wechat</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用cookie，session，token去做身份验证]]></title>
    <url>%2F2017%2F07%2F28%2Fcookie-session-token%2F</url>
    <content type="text"><![CDATA[解决几个疑惑 HTTP 是一个无连接且无状态协议，客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？ 如何对用户进行身份验证？ 关键字 token、cookie和session 的理解token 令牌是验证身份的一种方式。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。 引申问题 攻击者会不会伪造token? cookie浏览器里一种能永久保存的数据。由服务器产生，发送给浏览器。 cookie的组成有：名称(key)、值(value)、有效域(domain)、路径(域的路径，一般设置为全局:”\”)、失效时间(expires)、安全标志(指定后，cookie只有在使用SSL连接时才发送到服务器(https))。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。 读取cookie document.cookie 写入cookie document.cookie = &#39;name=abigale&#39; 以下是我从某个网站截取下的请求信息，可以看到 cookie 里的信息 例子: expires设置有效时间 123let date = new Date();date.setDate(date.getDate+30);document.cookie = 'name=abc;path=/;expires='+date; session 会话当用户去访问某个服务器时，服务器会产生session然后存下用户的信息。session是通过 session_id 去识别用户的。 session存放位置可以是 内存 cookie本身 redis 或 memcached 等缓存中 数据库中。（线上来说，缓存的方案比较常见，存数据库的话，查询效率相比前三者都太低，不推荐） 传统的身份验证：cookie和session之间的合作说在cookie和session之前： 为什么会有cookie又有session： 原因一：因为如果我们把所有信息全都存在cookie，cookie有很容易被用户在浏览器看到或者在js脚本修改，cookie存储数据大小也受限，太大传输效率就低了，所以我们把一些敏感或者量大的数据存在session里。 原因二：将两者信息进行匹配验证，即浏览器(cookie)和服务器端(session)之间的验证。 为什么需要这两者的合作？ HTTP是一种无状态无连接的协议，即请求是不知道是谁请求，需要在这两者之间做一层身份的识别。就如原本是去商场用现金交易，付款后就不知道用户是谁了，但后来变成线上支付，加了一层身份识别，我们就可以对用户进行追踪了。 合作过程 客户端访问时，通过了验证。 服务端将客户端信息进行处理加密(签名，专业术语叫信息摘要算法)。 把记录这些信息的ID发送给客户端 客户端收到ID后存储在cookie中 下次客户端重新访问服务端时，带上cookie信息 服务端验证cookie里面的信息，如果能找到对应的记录，则用户通过了验证 引申出的问题：为什么要加密？比如我们放在浏览器的信息是可以通过js拿到的或者其他攻击拿到的，很不安全。如果我们通过某种信息加密手段，就可以防止攻击者冒充用户去干坏事。 可以怎么加密呢？下面举个例子 秘密字符串：如 &quot;thisIsMySecret&quot; 本来发送给服务端的cookie: &quot;name:abigale&quot;,这时abigale用户可以伪装成另一位同学yuhaha，如cookie: &quot;name:yuhaha&quot; 这是服务器做个sha1加密：sha1(&quot;thisIsMySecret&quot;,&quot;abigale&quot;),然后把某个加密后的签名（如：4850a42e3bc0ac94323d3923e3d1d）发给用户 后来用户发给服务器端的cookie就变成了 1234&#123; name: 'abigale', 'user.sig': '4850a42e3bc0ac94323d3923e3d1d'&#125; 到这时，如果攻击者将cookie改为 1234&#123; name: 'yuhaha', 'user.sig': '4850a42e3bc0ac94323d3923e3d1d'&#125; 签名就匹配不上了，要伪造对应的签名几率很小很小 这就是完成一个加密过程了。这个过程是用来识别用户，针对了HTTP面向无连接（请求完就断开）的方法。 新的验证机制 – token认证以上我们讲到我们采用 session_id 去匹配用户验证用户完成一次API请求，但每次请求都要去做匹配。一种新的请求机制是token认证 快速理解：我们将一些需要验证的信息在服务端做一次加密，包括一些失效期等，然后返回给客户端，客户端将token存起来，下次访问再讲token传给服务端验证。 参考 cookie、session和token那些事 token/session/cookie的区别 基于Token的WEB后台认证机制]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window.open()被浏览器拦截了]]></title>
    <url>%2F2017%2F07%2F21%2Fwindow-open%2F</url>
    <content type="text"><![CDATA[在项目中遇到一个问题：JavaScript脚本用 window.open 打开一个窗口被浏览器拦截了。 window.open('https://abigaleypc.github.io/'); 不出意外的话此时浏览器已经拦截了一个页面了，除非浏览器被设置为默认不拦截任何窗口。 弹出窗口的原因是页面被注入了以下代码。 123&lt;script&gt; window.open('https://abigaleypc.github.io/');&lt;/script&gt; 被拦截的原因是页面并非用户所触发，所以被浏览器拦截了。 解决方法：让用户触发窗口弹出假如让用户触发窗口打开，代码如下： 弹出 var btn = document.getElementById('popups'); btn.addEventListener('click',function(){ window.open('https://abigaleypc.github.io/'); }) 1234567&lt;button id="popups"&gt;弹出&lt;/button&gt;&lt;script&gt; var btn = document.getElementById('popups'); btn.addEventListener('click',function()&#123; window.open('https://abigaleypc.github.io/'); &#125;)&lt;/script&gt; 解决Ajax请求出现的拦截1234567891011121314151617181920212223242526272829&lt;a href="javascript:;" onclick="dialog();"&gt;点击弹窗&lt;/a&gt; &lt;script&gt;function dialog()&#123; $.ajax(&#123; url: 'url', type: 'POST', dataType: 'json', async: false, // 此处必须定义为同步 data: &#123;param1: 'value1'&#125;, success: function(data)&#123; gotourl(data.url); //发起弹窗 &#125; &#125;)&#125; /** * 弹窗 * @param &#123;string&#125; url 跳转链接 */function gotourl(url)&#123; var a = $('&lt;a href="'+ url +'" target="_blank"&gt;链接&lt;/a&gt;'); //生成一个临时链接对象 var d = a.get(0); var e = document.createEvent('MouseEvents'); e.initEvent( 'click', true, true ); //模拟点击操作 d.dispatchEvent(e); a.remove(); // 点击后移除该对象&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.prototype.toString.call() vs typeof]]></title>
    <url>%2F2017%2F07%2F05%2FObject-prototype-toString-call-vs-typeof%2F</url>
    <content type="text"><![CDATA[可以从下面例子找到答案： 12345678910111213141516var toString = Object.prototype.toString;var strLit = 'example';var strStr = String('example')​;var strObj = new String('example');console.log(typeof strLit); // string console.log(typeof strStr); // stringconsole.log(typeof strObj); // objectconsole.log(strLit instanceof String); // falseconsole.log(strStr instanceof String); // falseconsole.log(strObj instanceof String); // trueconsole.log(toString.call(strLit)); // [object String]console.log(toString.call(strStr)); // [object String]console.log(toString.call(strObj)); // [object String]]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prototype和__proto__]]></title>
    <url>%2F2017%2F07%2F05%2Fprototype%E5%92%8C-proto%2F</url>
    <content type="text"><![CDATA[Object/Function/Array/String 原型链注入一个奇怪的观念： Function.prototype 独立于/先于 Function 存在； Object.prototype 独立于/先于 Object 存在 12345Object.prototype.__proto__ ; // null 因此 Object.prototype 是原型链的终点Function.__proto__ === Function.prototype; // trueObject.__proto__ === Function.prototype; // trueArray.__proto__ === Function.prototype; // trueString.__proto__ === Function.prototype; // true 由上图我们可以看出原型链是 Object.prototype –&gt; Function.prototype –&gt; Object/Array/String/Function…… 类和实例在JS中，类实际就是一个函数。 对类进行实例化，采用关键字 new，例子如下： 12345function Animal(name) &#123; this.name = name;&#125;Animal.prototype.say = "Hello";let animal = new Animal("animal"); 以上 Animal是类,animal 是实例 输入：animal 输出： 定义一个函数的时候，js会自动给这个函数添加一个 prototype 的属性，值是空对象。 每一个JS对象都有一个 __proto__ 属性，但 prototype属性只有函数才有。 我们将上面的代码画成图： 可以看出: 1animal.__proto__ === Animal.prototype; // true 实例继承构造函数prototype的所有属性和方法。 我们可以通过实例去使用构造函数的属性和方法，如下： 12console.log(animal.say); // Helloconsole.log(animal.constructor === Animal); // true,constructor 属性指代这个类 instanceof : 用于判断一个变量是否某个对象的实例 [instance：实例,例子] this 和 prototype 获取到的属性和方法，有什么区别？ 123456789function Animal(name) &#123; this.name = name;&#125;Animal.prototype.say = "hello"let dog = new Animal("dog")console.log(dog.name); // dogconsole.log(dog.say); // hello 同样是能获取到所继承的类的属性，但有一个弊端是当有多个对象继承该类时，只是用 `this` 的话，资源没办法共享，所以采用 `prototype` 资源的共享，当需要修改 `prototype` 中的某个属性或方法时，只需要 `Animal.prototype.say = &quot;hi&quot;` 参考 从proto和prototype来深入理解JS对象和原型链 Javascript继承机制的设计思想 类和继承类的继承可以用 call 和 apply 方法实现，它们的异同如下： 相同点:两个方法产生的作用是完全一样的,用于改变this指向 不同点:方法传递的参数不同]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native DEMO]]></title>
    <url>%2F2017%2F07%2F01%2Freactnative-demo%2F</url>
    <content type="text"><![CDATA[demo介绍这是一个聊天APP GitHubhttps://github.com/abigaleypc/react-native-demo.git 安装项目 git clone https://github.com/abigaleypc/react-native-demo.git cd demo npm install 启动项目 进入项目文件夹 demo –&gt; ios, 打开 demo.xcodeproj , 启动 最终效果 实现过程页面切换页面切换通过导航 navigator 切换，该项目由两个页面组成，即 好友列表 和 聊天窗口 在 index.ios.js 中 1234567891011121314151617let defaultName = 'FriendsSence'; // 默认进入路由的名称let defaultComponent = FriendsSence; // 默认进入的窗口&lt;Navigator style=&#123;styles.nav&#125; initialRoute=&#123;&#123; name: defaultName, component: defaultComponent &#125;&#125; configureScene=&#123;(route) =&gt; &#123; return Navigator.SceneConfigs.VerticalDownSwipeJump; &#125;&#125; renderScene=&#123;(route, navigator) =&gt; &#123; let Component = route.component; return &lt;Component &#123;...route.params&#125; navigator=&#123;navigator&#125; // 将导航传给待渲染的窗口 /&gt; &#125; &#125;/&gt; 以上将导航传给下一个窗口的原因可以参考：新手理解Navigator的教程 FriendsSence 是第一个窗口，即 好友列表，下一个窗口是 ChatSence ,即 聊天窗口。 在 friendSence.js 中，如何跳转至窗口ChatSence 并带上用户的信息呢？ 1234567this.props.navigator.push(&#123; name: 'ChatSence', component: ChatSence, params: &#123; name: rowData.name &#125;&#125;) 这样就在堆栈里新增一个窗口，返回的话在这个堆栈去掉目前窗口即可，如下： 1this.props.navigator.pop(); 也可以像跳入聊天窗口一样的方法跳入好友列表窗口 列表渲染列表渲染采用 ListView，参考 12345678910const ds = new ListView.DataSource(&#123; rowHasChanged: (r1, r2) =&gt; r1 !== r2 &#125;);this.state = &#123; dataSource: ds.cloneWithRows(msgsData[this.props.name])&#125;&lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125;/&gt; 消息队列12345this.setState(&#123; dataSource: this.state.dataSource.cloneWithRows( [...this.state.dataSource._dataBlob.s1, ...this.state.inputing])&#125;) this.state.inputing 是需要增加的信息 this.state.dataSource._dataBlob.s1 是原数据 过程遇到的问题 类规范：引入的类名需首字母大写 样式不会继承 所以设置字体大小的话只在header里设置并不会在headerText生效 123&lt;View style=&#123;styles.header&#125;&gt; &lt;Text style=&#123;styles.headerText&#125;&gt;&#123;this.props.title&#125;&lt;/Text&gt; &lt;/View&gt; TouchableHighlight 按钮文字 1&lt;TouchableHighlight&gt;文字&lt;/TouchableHighlight&gt; //这么写是会报错的 应改为 1&lt;TouchableHighlight&gt;&lt;Text&gt;文字&lt;/Text&gt;&lt;/TouchableHighlight&gt; 用闭包解决 this 读取不到的问题 1&lt;TouchableOpacity style=&#123;styles.sendBtn&#125; onPress=&#123;this.sendMsg()&#125; &gt; 应改为 1&lt;TouchableOpacity style=&#123;styles.sendBtn&#125; onPress=&#123;()=&gt;&#123;this.sendMsg()&#125;&#125; &gt;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于微信小程序开发的聊天小Demo]]></title>
    <url>%2F2017%2F07%2F01%2Fwxapp-demo%2F</url>
    <content type="text"><![CDATA[小程序介绍仿聊天窗口的微信小程序 GitHubhttps://github.com/abigaleypc/wxapp-demo.git 准备工作 获取开发资格 下载开发工具 安装并启动项目 git clone https://github.com/abigaleypc/wxapp-demo.git 在开发者工具中添加以上demo，即可查看效果 最终效果 实现过程 该小程序主要由两个界面组成：好友列表 和 聊天窗口。 文件介绍 .wxml后缀是页面的结构文件 .js后缀的是脚本文件 .json后缀的文件是配置文件 .wxss后缀的是样式表文件 “好友列表”界面在friends.wxml中，显示好友列表 由 &lt;scroll-view&gt; 渲染可滚动视图区域，官方文档 - scroll-view 由 wx:for 进行列表渲染，官方文档 - 列表渲染 数据绑定：在friends.js中定义需要绑定到页面的数据变量 页面跳转：navigator用于页面链接，此项目用于页面跳转至聊天窗口。官方文档 - navigator 123456789101112&lt;view class="container"&gt; &lt;view class="page-body"&gt; &lt;scroll-view scroll-y="true" style="height: 900rpx;" bindscrolltoupper="upper" bindscrolltolower="lower" bindscroll="scroll" scroll-into-view="&#123;&#123;toView&#125;&#125;" scroll-top="&#123;&#123;scrollTop&#125;&#125;"&gt; &lt;view wx:for="&#123;&#123;friends&#125;&#125;" wx:key="id"&gt; &lt;navigator url="chat?id=&#123;&#123;index+1&#125;&#125;" hover-class="navigator-hover" class="friend-item"&gt; &lt;image class="avatar" src="&#123;&#123;item.avatarPath&#125;&#125;"/&gt; &lt;view class="name"&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt;&lt;/view&gt; 在 friends.js 中，渲染好友列表的逻辑在该文件实现，比如数据绑定，触发事件等 1234567891011121314151617181920212223242526272829Page(&#123; data: &#123; greeting: 'hello', ... &#125;, onLoad: function (options) &#123; &#125;, onReady: function () &#123; // Do something when page ready. &#125;, onShow: function () &#123; // Do something when page show. &#125;, onHide: function () &#123; // Do something when page hide. &#125;, onUnload: function () &#123; // Do something when page close. &#125;, onPullDownRefresh: function () &#123; // Do something when pull down. &#125;, onReachBottom: function () &#123; // Do something when page reach bottom. &#125;, onShareAppMessage: function () &#123; // return custom share data when user share. &#125;,&#125;); “聊天窗口”界面在chat.wxml中，显示聊天记录 由 wx:if 进行条件渲染，判断每条聊天记录是来自本人还是好友，当是好友信息时显示在屏幕左边，否则显示在右边。官方文档 - 条件渲染 12345678910111213141516171819202122232425262728&lt;view class="container"&gt; &lt;view class="page-body"&gt; &lt;scroll-view class="msg-list" enable-back-to-top scroll-y="true" scroll-top="&#123;&#123;scrollTop&#125;&#125;"&gt; &lt;view wx:for="&#123;&#123;chatInfo.msg&#125;&#125;" wx:key="$index"&gt; &lt;view wx:if="&#123;&#123;item.type == 'friend'&#125;&#125;" class="friend"&gt; &lt;view&gt; &lt;image class="avatar" src="&#123;&#123;chatInfo.userInfo.avatarPath&#125;&#125;"/&gt;&lt;/view&gt; &lt;view class="triangle"&gt; &lt;view class="b-triangle f-b-triangle"&gt;&lt;/view&gt; &lt;view class="t-triangle f-t-triangle"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="item-msg"&gt;&#123;&#123;item.msg&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view wx:else class="self"&gt; &lt;view&gt; &lt;image class="avatar" src="&#123;&#123;chatInfo.userInfo.avatarPath&#125;&#125;"/&gt;&lt;/view&gt; &lt;view class="triangle"&gt; &lt;view class="b-triangle s-b-triangle"&gt;&lt;/view&gt; &lt;view class="t-triangle s-t-triangle"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="item-msg"&gt;&#123;&#123;item.msg&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;view class="msg-input"&gt; &lt;input class="send-input" auto-focus bindinput="msgContent" value="&#123;&#123;inputValue&#125;&#125;"/&gt; &lt;button class="send-btn" bindtap="sendMsg"&gt;发送&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 弹性布局 微信小程序界面布局与React Native一样，采用弹性布局(Flexbox)，Flex是Flexible Box的缩写，用来为盒状模型提供最大的灵活性。 Flex有三个常用属性：flex-direction, justify-content 和 align-items 过程遇到的问题 微信小程序如果使用input，没办法想 AngularJS 或者 VueJS一样实现数据双向绑定，解决办法如下 12345678910111213141516171819// 页面结构&lt;view class="msg-input"&gt; &lt;input class="send-input" auto-focus bindinput="msgContent" value="&#123;&#123;inputValue&#125;&#125;"/&gt; &lt;button class="send-btn" bindtap="sendMsg"&gt;发送&lt;/button&gt;&lt;/view&gt;// 脚本文件中获取页面中输入值msgContent: function (e) &#123; this.setData(&#123; inputValue: e.detail.value &#125;)&#125;// 对页面输入值进行清空sendMsg: function () &#123; this.setData(&#123; inputValue: '' )&#125; 使用 wx:for 进行列表渲染，这个列表是可能被用户操作的，可能会报错，根据官方文档可查到 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 解决办法如下: 加上 wx:key 1&lt;view wx:for="&#123;&#123;friends&#125;&#125;" wx:key="id"&gt; 需要注意一点的是：微信小程序不能直接操作DOM，如 document.getElementsByClassName(&#39;test&#39;); 是错误的]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>wxapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 分享]]></title>
    <url>%2F2017%2F06%2F29%2FReact-Native-%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端本地存储策略 -- cookie, sessionStorage 和 localStorage]]></title>
    <url>%2F2017%2F06%2F26%2F%E5%89%8D%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%AD%96%E7%95%A5-cookie-sessionStorage-%E5%92%8C-localStorage%2F</url>
    <content type="text"><![CDATA[前端本地存储策略 通过本地存储（Local Storage），web 应用程序能够在用户浏览器中对数据进行本地的存储。在 HTML5 之前，应用程序数据只能存储在 cookie 中，包括每个服务器请求。本地存储则更安全，并且可在不影响网站性能的前提下将大量数据存储于本地。与 cookie 不同，存储限制要大得多（至少5MB），并且信息不会被传输到服务器。本地存储经由起源地（origin）（经由域和协议）。所有页面，从起源地，能够存储和访问相同的数据。 从以下几点做一些对比： 存储量 存储类型 使用方式 数据的生命期 与服务器端通信 优点 缺点 存储量 cookie: 4KB sessionStorage: 一般为5MB localStorage: 一般为5MB 存储类型 cookie: 字符串 sessionStorage: 键值对 localStorage: 键值对 使用方式 cookie: 获取 cookie 可以直接使用 document.cookie ，但是获取到的 cookie 是一个字符串，它包含了 cookie 中存储的所有数据，形式如 &quot;key1=value1; key2=value2&quot; sessionStorage: 普通对象非常相似，可以直接通过中括号 sessionStorage[‘key’] 的方式添加和获取数据，也可以通过点语法 sessionStorage.key 的方式进行操作，sessionStorage 也有自己的 api 用于操作数据。或者sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;)；var data = sessionStorage.getItem(&#39;key&#39;) localStorage: 同上 数据的生命期 cookie: 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 sessionStorage: 仅在当前会话下有效，关闭页面或浏览器后被清除 localStorage: 除非被清除，否则永久保存 与服务器端通信 cookie: 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 sessionStorage: 仅在客户端（即浏览器）中保存，不参与和服务器的通信 localStorage: 同上 优点 cookie: 有大量的库可供我们更方便快捷得操作 cookie ，如 jQuery.cookie.js sessionStorage: 存储的数据不会被自动随着请求被发送到服务端 可存储的数据大小相比 cookie 来说大了很多，但是每个浏览器都不同，所以没有一个统一的值。 localStorage: 数据存储量大； 不会被发送到服务端； 持久化本地存储，除非手动删除，否则一直存在； 在同一个域下，所有窗口共享其中存储的数据 (sessionStorage则不可) 缺点 cookie: 如 &quot;key1=value1; key2=value2&quot; 这样的字符串无法通过 JSON.parse() 转换为 json 格式的数据，需要通过正则表达式的方式将所需要的值匹配出来 sessionStorage: sessionStorage 中只能够保存字符串类型的数据，所以在保存非字符串类型的数据时，一定要先将其转换成字符串，比如图片可以转换成 base64 字符串后保存，对象可使用 JSON.stringify() 转为字符串后存储，甚至可以存储一段 js 脚本 其中所存储的数据的生命周期与 session 类似，即只存在于一个会话周期内，当浏览器关闭或标签页关闭时，数据即会被删除（前进和后退并不会影响到数据，因为还在当前的会话中），这就导致了即便是同一个网站，但在不同的标签页和窗口内，也无法共享其中存储的数据 localStorage: 只能够保存字符串类型的数据，所以在保存非字符串类型的数据时，一定要先将其转换成字符串，比如图片可以转换成 base64 字符串后保存，对象可使用 JSON.stringify() 转为字符串后存储，甚至可以存储一段 js 脚本 seesionStorage例子12345678910111213141516171819202122/** * 向 sessionStorage 中添加一条数据 * @param key &#123;string&#125; 键 * @param value &#123;string&#125; 值 */sessionStorage.setItem( key, value ) /** * 在 sessionStorage 中读取一条数据 * @param key &#123;string&#125; 键 * @return &#123;string|null&#125; 存在返回值，不存在返回 null，需要注意的是如 果使用点语法和中括号，不存在时返回 undefined */sessionStorage.getItem( key ) * 在 sessionStorage 中移除一条数据 * @param key &#123;string&#125; 键 */sessionStorage.removeItem( key ) * 在 sessionStorage 中移除所有 */sessionStorage.clear()]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端模拟服务器实现跨域]]></title>
    <url>%2F2017%2F06%2F23%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[DEMOhttps://github.com/abigaleypc/cross-domain-server 项目安装 git clone https://github.com/abigaleypc/cross-domain-server cd JSONP npm install 不同域的定义协议+域名+端口号都相同才是同域 XMLHttpRequest跨域访问通过以上例子我们已经可以通过 XMLHttpRequest 对象实现一个HTTP请求，但以上方法只能向同域下进行请求 如 XHR/port8080 中 1request.open('GET', 'http://127.0.0.1:8080/test.txt'); 如 XHR/port58023 中 1request.open('GET', 'http://127.0.0.1:58023/test.txt'); 如果我在 port8080 中将 58023 改为 8080,可以看到浏览器报了以下错误 这就出现了跨域的问题（端口号不同）。 JSONP解决跨域问题 简单理解下JSONP的原理：AJAX不能实现跨域的请求，但却能将不能请求的文件通过 &lt;script&gt;获取到，如 &lt;script src=&quot;xxx.js&quot;&gt;&lt;/script&gt;，详细文档 tip: port8080主要用来访问不同域的子项目，port58023主要模拟服务器，启动另一个端口给port8080访问 cd JSONP 在文件夹 JSONP/port8080/index.html 中，我们引入的是另一个端口下的文件，文件同样获取到了，这时候打开浏览器控制台可以看到返回结果被打印出来了。 123456&lt;script&gt; function callback(data) &#123; console.log(data) &#125;&lt;/script&gt;&lt;script src="http://127.0.0.1:58023/test.js"&gt;&lt;/script&gt; 在文件夹 JSONP/port58023 中，我们可以看下 test.js文件 12345callback( &#123; "port": "我不是8080端口" &#125;) 控制台已经打印出文本，只是因为 callback() 函数被调用并被打印出来了。 以上就是JSONP的实现原理。一般情况下，我们希望这个script标签能够动态的调用，而不是像上面因为固定在html里面所以没等页面显示就执行了，很不灵活。我们可以通过javascript动态的创建script标签，这样我们就可以灵活调用远程服务了。 我们可以将 JSONP/post8080/index.html 脚本改成 12345678910111213141516&lt;script type="text/javascript"&gt; function callback(data) &#123; alert(data.message); &#125; // 添加&lt;script&gt;标签的方法 function addScriptTag(url)&#123; var script = document.createElement('script'); script.setAttribute("type","text/javascript"); script.src = url; document.body.appendChild(script); &#125; window.onload = function()&#123; addScriptTag("http://localhost:20002/test.js"); &#125;&lt;/script&gt; 实现以上过程的前提是后端提供callback字段，如https://api.douban.com/v2/user/abigaleypc?callback=__callback5,我们可以在参数加上callback是因为后端的支持，就像以上 JSONP/port58023/test.js 中 12345callback( &#123; "port": "我不是8080端口" &#125;)]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP请求]]></title>
    <url>%2F2017%2F06%2F23%2Fhttp%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[HTTP请求一个HTTP请求一般由四个部分组成 HTTP请求的动作或者方法，比如是GET或者POST请求。 GET请求. 一般用于信息获取。（一般用来查询）；使用URL传递参数；对发送的数据信息有限制，一般在2000个字符。 POST请求。 一般用于修改服务器上的资源。（一般用来修改数据）；对与大小没有限制； 正在请求的URL。你要知道你请求的地址是什么。 请求头，包含一些客户环境，身份验证信息等等。 请求体，也就是请求正文，这里面包含查询的字符串，表单信息等等。 头域详解HTTP的头域包括通用头、请求头、响应头和实体头四个部分。每个头域由一个域名，冒号（:）和域值三部分组成。 通用头部是客户端和服务器都可以使用的头部，可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。 请求头部是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部。 响应头部便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部。 实体头部指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。 参考链接 状态码 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 常见状态码 200 – 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务器超时 参考链接 XMLHttpRequest(XHR)对象兼容IE6及以下版本12345678if (window.XMLHttpRequest) &#123;// code for all new browsers xmlhttp=new XMLHttpRequest(); &#125;else if (window.ActiveXObject) &#123;// code for IE5 and IE6 xmlhttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; XMLHttpRequest发送请求方法 open(merhod, url, async) 建立请求 。async 为是否异步，默认为true send(srting) 发送请求 例子123456789request.open("GET","get.php",true); request.send();request.open("POST","post.php",true);request.send();request.open("POST","create.php",true);request.setRequestHeader("Content-type","application/x-www-form-urlencoded");request.send("name=abigele&amp;sex=female"); XMLHttpRequest取得响应方法 onreadystatechange* 指定当readyState属性改变时的事件处理句柄。只写 readyState 返回当前请求的状态，只读. responseBody 将回应信息正文以unsigned byte数组形式返回.只读 responseStream 以Ado Stream对象的形式返回响应信息。只读 responseText 将响应信息作为字符串返回.只读 responseXML 将响应信息格式化为Xml Document对象并返回，只读 status 返回当前请求的http状态码.只读 statusText 返回当前请求的响应行状态，只读 getResponseHeader(headerName) 获取某个请求头 getAllResponseHeader() 获取所有请求头 例子12345678var request = new XMLHttpRequest();request.open("GET","get.php",true);request.send();request.onreadystatechange = function() &#123; if(request.readyState === 4 &amp;&amp; request.status === 200) &#123; // request.responseText &#125;&#125; 示例代码 npm init npm install live-server --save 新建 test.txt 123&#123; "name":"aa"&#125; 新建 index.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt;&lt;/head&gt;&lt;style&gt; .modal &#123; float: left; margin-right: 20px; border: 1px solid #eee; padding: 10; &#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;HTTP请求&lt;/h1&gt; &lt;div class="modal"&gt; &lt;h3&gt;responseText&lt;/h3&gt; &lt;p class="responseText"&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class="modal"&gt; &lt;h3&gt;allResponseHeader&lt;/h3&gt; &lt;p class="requestHeader"&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; let requestData = document.getElementsByClassName("responseText")[0]; let requestHeader = document.getElementsByClassName("requestHeader")[0]; let request = new XMLHttpRequest(); request.open('GET', 'http://127.0.0.1:8080/test.txt'); request.send(); request.onreadystatechange = function () &#123; console.log(request) if (request.readyState == 4) &#123; requestData.innerHTML = `&lt;pre&gt;$&#123;request.responseText&#125;&lt;/pre&gt;` requestHeader.innerHTML = `&lt;pre&gt;$&#123;request.getAllResponseHeaders()&#125;&lt;/pre&gt;` &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; live-server 结果显示]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native使用导航器跳转页面]]></title>
    <url>%2F2017%2F06%2F14%2Freact-native%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%88%AA%E5%99%A8%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[react-native中导航库react-navigation实现过程： 安装库 npm install --save react-navigation index.ios.js中代码示例 12345678910111213141516171819202122232425262728293031323334import React from 'react';import &#123; AppRegistry, View, Text, Button&#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation'; // 引入import ChatScreen from './src/component/ChatScreen';class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Navigation!&lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; navigate('Chat')&#125; title="Chat with Lucy" /&gt; &lt;/View&gt; ) &#125;&#125;const AwesomeProject = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Chat: &#123; screen: ChatScreen &#125;,&#125;);AppRegistry.registerComponent('AwesomeProject', () =&gt; AwesomeProject); 在根目录建文件夹./src/component,并创建文件ChatScreen.js ChatScreen.js代码示例：123456789101112131415161718import React, &#123; Component &#125; from 'react';import &#123; Text, View&#125; from 'react-native';export default class ChatScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Chat with Lucy', &#125;; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Chat with Lucy&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 实现过程所遇问题： index.ios.js 最后注册的是将导航栏 AwesomeProject，此处注册的不是 HomeScreen]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css样式优先级]]></title>
    <url>%2F2017%2F05%2F31%2Fcss%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[id &gt; class &gt; 元素(类型)选择器 1234567// html&lt;h1 class="h1-class" id="h1-id"&gt;这是标题&lt;/h1&gt;// CSS.h1-class &#123; color: goldenrod; &#125; // 第二优先级#h1-id&#123; color: blue; &#125; // 第一优先级h1&#123; color: red; &#125; // 第三优先级 指定元素 &gt; 非指定元素 123456789// html &lt;div id="test"&gt; &lt;span&gt;Text&lt;/span&gt;&lt;/div&gt;// CSSdiv#test span &#123; color: green &#125; // 第一优先级span &#123; color: red &#125; // 第三优先级div span &#123; color: blue &#125; // 第二优先级]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数组]]></title>
    <url>%2F2017%2F05%2F23%2FJavaScript%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[小知识 JavaScript数组长度范围 10 ~ 2^32-2 数组直接量的语法允许有可选的结尾的逗号 12let arr = [,,];console.log(arr.length); // 2 数组是对象的特殊形式:以下例子索引变成对象属性 123o = &#123;&#125;;o[0] = "one";console.log(o); // &#123; '0': 'one' &#125; 当给数组设置长度值时，在长度值范围内的值将被删除 123a = [12,23,34,45];a.length = 2;console.log(a); // [12,23] 将数组设为只读 123a = [1,2,3];Object.defindProperty(a,"lengrh",&#123;writable:false&#125;);a.length = 0; // a长度不会被改变 冻结数组对象：使数组对象不可删除或修改它的属性 123a = [1,2,3];Object.freeze(a);a.length = 0; // a长度不会被改变 Array各类方法Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。12345let arr = 'abc'let newArr = Array.from(a);console.log(newArr); // [ 'a', 'b', 'c' ]console.log(Array.from([1, 2, 3], x =&gt; x + x)); // [2, 4, 6] Array.isArray() 用于确定传递的值是否是一个 Array。1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray("foobar"); // falseArray.isArray(undefined); // false Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。12345Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3] Array.concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。1234567let arr1 = ["a", "b", "c"];let arr2 = ["d", "e", "f"];let arr3 = arr1.concat(arr2);console.log(arr3); // [ "a", "b", "c", "d", "e", "f" ]console.log(arr1); // ["a", "b", "c"]console.log(arr2); // ["d", "e", "f"] copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。123456789101112// 三个参数：let a = ["alpha", "beta", "copy", "delta", "erro", "fetch", "goooo"].copyWithin(0, 3, 6);// 参数1为索引值，也就是目标值 a[0] = "alpha";// 参数2 参数3 为范围，范围是a[3]-a[6],即a[3],a[4],a[5]。注意：不包括 a[6]// 原数组是 a[0],a[1],a[2],a[3],a[4],a[5],a[6]// 新数组是 a[3],a[4],a[5],a[3],a[4],a[5],a[6]console.log(a); // [ 'delta', 'erro', 'fetch', 'delta', 'erro', 'fetch', 'goooo' ]// 两个参数：var fruits = ["Banana", "Orange", "Apple", "Mango"];fruits.copyWithin(2, 0); // ["Banana", "Orange", "Apple", "Mango"]; // 将a[0]付给a[2] entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。12345678var arr = ["a", "b", "c"];var iterator = arr.entries(); // undefinedconsole.log(iterator); // Array Iterator &#123;&#125;console.log(iterator.next().value); // [0, "a"]console.log(iterator.next().value); // [1, "b"]console.log(iterator.next().value); // [2, "c"] fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。1234var numbers = [1, 2, 3]numbers.fill(1);// results in [1, 1, 1] join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。12345678910111213141516let a = ['Wind', 'Rain', 'Fire'];a.join(); // 默认为 ","// 'Wind,Rain,Fire'a.join(""); // 分隔符 === 空字符串 ""// "WindRainFire"a.join("-"); // 分隔符 "-"// 'Wind-Rain-Fire'console.log(a);// ['Wind', 'Rain', 'Fire'] map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。123456789101112131415161718let numbers = [1, 5, 10, 15];let roots = numbers.map((x) =&gt; &#123; return x * 2;&#125;);let roots = numbers.map( x =&gt; x * 2);// roots is now [2, 10, 20, 30]// numbers is still [1, 5, 10, 15]let numbers = [1, 4, 9];// let roots = numbers.map(Math.sqrt);let roots = numbers.map(function(x)&#123; return Math.sqrt(x);&#125;);// roots is now [1, 2, 3]// numbers is still [1, 4, 9] pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。1234567let a = [1, 2, 3];a.length; // 3a.pop(); // 3console.log(a); // [1, 2]a.length; // 2 push() 方法将一个或多个元素添加到数组的末尾，并返回数组的新长度。12345678910var numbers = [1, 2, 3];numbers.push(4);console.log(numbers); // [1, 2, 3, 4]numbers.push(5, 6, 7);console.log(numbers); // [1, 2, 3, 4, 5, 6, 7] reduce() 方法对累加器和数组中的每个元素 (从左到右)应用一个函数，将其减少为单个值。123456789101112131415161718192021222324let sum = [0, 1, 2, 3].reduce(function(acc, val) &#123; return acc + val;&#125;, 0);console.log(sum);// 6let list1 = [[0, 1], [2, 3], [4, 5]];let list2 = [0, [1, [2, [3, [4, [5, [6]]]]]]];const flatten = (arr) =&gt; &#123; return arr.reduce( (acc, val) =&gt; &#123; return acc.concat(Array.isArray(val) ? flatten(val) : val) &#125;, [] );&#125;;flatten(list1); // [0, 1, 2, 3, 4, 5]flatten(list2); // [ 0, 1, 2, 3, 4, 5, 6 ] reverse 方法颠倒数组中元素的位置，并返回该数组的引用。1234var myArray = ['one', 'two', 'three'];myArray.reverse(); console.log(myArray) // ['three', 'two', 'one'] shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。12345678let a = [1, 2, 3];let b = a.shift();console.log(a); // [2, 3]console.log(b); // 1 shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。12345678let a = [1, 2, 3];let b = a.shift();console.log(a); // [2, 3]console.log(b); // 1 slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。1234let a = [0,1,2,3];let sliced = a.slice(1,3);console.log(a); // [0, 1, 2, 3]console.log(sliced); // [1, 2] splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。12345678910var myFish = ["angel", "clown", "mandarin", "sturgeon"];myFish.splice(2, 0, "drum"); // myFish is ["angel", "clown", "drum", "mandarin", "sturgeon"] myFish.splice(2, 1); // myFish is ["angel", "clown", "sturgeon"] myFish.splice(2, 1, "splice", "parrot");// myFish is ["angel", "clown", "splice", "parrot", "sturgeon"] unshift() 方法将一个或多个元素添加到数组的开头，并返回新数组的长度。12345let a = [1, 2, 3];a.unshift(4, 5);console.log(a);// [4, 5, 1, 2, 3] @@iterator 循环迭代使用 for…of123456var arr = ['w', 'y', 'k', 'o', 'p'];// 您的浏览器必须支持for...of循环// 以及let —— 将变量作用域限定在 for 循环中for (let letter of arr) &#123; console.log(letter);&#125; 使用迭代器iterator1234567var arr = ['w', 'y', 'k', 'o', 'p'];var eArr = arr[Symbol.iterator]();console.log(eArr.next().value); // wconsole.log(eArr.next().value); // yconsole.log(eArr.next().value); // kconsole.log(eArr.next().value); // oconsole.log(eArr.next().value); // p]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[json数据操作总结]]></title>
    <url>%2F2017%2F05%2F22%2Fjson%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JSON.stringify() 将JSON格式转为string格式 12let jsonObj = &#123;a:1,b:2&#125;;JSON.stringify(jsonObj); // '&#123;a:1,b:2&#125;' JSON.parse() 将string格式转为JSON格式。注意：字符串中key一定要用上双引号，如下面示例中的 &quot;a&quot; 12let strObj = '&#123;"a":1,"b":2&#125;';JSON.parse(strObj); // &#123;a: 1, b: 2&#125; Object.toJSON() Date类下的toJSON方法，返回一个Date对象转换成的字符串，格式化date对象，根据ISO-8601 标准改为 YYYY-MM-DDTHH:mm:ss.sssZ `jslet d = new Date(); // Mon May 22 2017 15:16:14 GMT+0800 (CST)d.toJSON(); // “2017-05-22T07:16:14.484Z”]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中Object.toString和Object.toLocaleString的区别]]></title>
    <url>%2F2017%2F05%2F22%2Fjs%E4%B8%ADObject-toString%E5%92%8CObject-toLocaleString%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[字符串返回结果相同 123let str = 123;str.toString(); // "123"str.toLocaleString(); //"123" 数组返回结果相同123let arr = [1,2,3];arr.toLocaleString(); // "1,2,3"arr.toString(); // "1,2,3" 如果是toString()，会直接返回标准的格式；如果是toLocaleString()，先判断是否指定语言环境（locale），指定的话则返回当前语言环境下的格式设置（options）的格式化字符串；没有指定语言环境（locale），则返回一个使用默认语言环境和格式设置（options）的格式化字符串。 根据MDN - toLocaleString， 内置对象override了toLocaleString的只有Array，Number和Date。所以，对于这三种对象，toLocaleString 的结果也 可能 会不同。 123let date = new Date();date.toLocateString(); // "2017-5-22 14:13:39"date.toString(); // "Mon May 22 2017 14:13:39 GMT+0800 (CST)" 123let num = 1234567890123;num.toLocaleString(); // "1,234,567,890,123"num.toString(); // "1234567890123"]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-toast3 插件开发详解]]></title>
    <url>%2F2017%2F05%2F19%2FVue-toast3-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言随着 Vue.js 越来越火，Vue.js 的相关插件也在不断的被贡献出来，数不胜数。比如官方推荐的 vue-router、vuex 等，都是非常优秀的插件。但是我们更多的人还只停留在使用的阶段，比较少自己开发。所以接下来会通过一个简单的 vue-toast 插件，来了解掌握插件的开发和使用。 认识插件想要开发插件，先要认识一个插件是什么样子的。 Vue.js 的插件应当有一个公开方法 install 。这个方法的第一个参数是 Vue 构造器 , 第二个参数是一个可选的选项对象:1234567891011121314151617181920MyPlugin.install = function (Vue, options) &#123; Vue.myGlobalMethod = function () &#123; // 1. 添加全局方法或属性，如: vue-custom-element // 逻辑... &#125; Vue.directive('my-directive', &#123; // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) Vue.mixin(&#123; created: function () &#123; // 3. 通过全局 mixin方法添加一些组件选项，如: vuex // 逻辑... &#125; ... &#125;) Vue.prototype.$myMethod = function (options) &#123; // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现 // 逻辑... &#125;&#125; 接下来要讲到的 vue-toast 插件则是通过添加实例方法实现的。我们先来看个小例子。先新建个js文件来编写插件：toast.js 123456// toast.jsvar Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; Vue.prototype.$msg = 'Hello World';&#125;module.exports = Toast; 在 main.js 中，需要导入 toast.js 并且通过全局方法 Vue.use() 来使用插件： 1234// main.jsimport Vue from 'vue';import Toast from './toast.js';Vue.use(Toast); 然后，我们在组件中来获取该插件定义的 $msg 属性。 123456// App.vueexport default &#123; mounted()&#123; console.log(this.$msg); // Hello World &#125;&#125; 可以看到，控制台成功的打印出了 Hello World 。既然 $msg 能获取到，那么我们就可以来实现我们的 vue-toast 插件了。 开发 vue-toast需求：在组件中通过调用 this.$toast(‘网络请求失败’) 来弹出提示，默认在底部显示。可以通过调用 this.$toast.top() 或 this.$toast.center() 等方法来实现在不同位置显示。 整理一下思路，弹出提示的时候，我可以在 body 中添加一个 div 用来显示提示信息，不同的位置我通过添加不同的类名来定位，那就可以开始写了。 123456789101112131415// toast.jsvar Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; Vue.prototype.$toast = (tips) =&gt; &#123; let toastTpl = Vue.extend(&#123; // 1、创建构造器，定义好提示信息的模板 template: '&lt;div class="vue-toast"&gt;' + tips + '&lt;/div&gt;' let tpl = new toastTpl().$mount().$el; // 2、创建实例，挂载到文档以后的地方 document.body.appendChild(tpl); // 3、把创建的实例添加到body中 setTimeout(function () &#123; // 4、延迟2.5秒后移除该提示 document.body.removeChild(tpl); &#125;, 2500) &#125;&#125;module.exports = Toast; &#125;); 好像很简单，我们就实现了 this.$toast() ，接下来显示不同位置。 123456// toast.js['bottom', 'center', 'top'].forEach(type =&gt; &#123; Vue.prototype.$toast[type] = (tips) =&gt; &#123; return Vue.prototype.$toast(tips,type) &#125;&#125;) 这里把 type 传给 $toast 在该方法里进行不同位置的处理，上面说了通过添加不同的类名(toast-bottom、toast-top、toast-center)来实现，那 $toast 方法需要小小修改一下。 123456Vue.prototype.$toast = (tips,type) =&gt; &#123; // 添加 type 参数 let toastTpl = Vue.extend(&#123; // 模板添加位置类 template: '&lt;div class="vue-toast toast-'+ type +'"&gt;' + tips + '&lt;/div&gt;' &#125;); ...&#125; 好像差不多了。但是如果我想默认在顶部显示，我每次都要调用 this.$toast.top() 好像就有点多余了，我能不能 this.$toast() 就直接在我想要的地方呢？还有我不想要 2.5s 后才消失呢？这时候注意到 Toast.install(Vue,options) 里的 options 参数，我们可以在 Vue.use() 通过 options 传进我们想要的参数。最后修改插件如下： 1234567891011121314151617181920212223242526272829303132var Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; let opt = &#123; defaultType:'bottom', // 默认显示位置 duration:'2500' // 持续时间 &#125; for(let property in options)&#123; opt[property] = options[property]; // 使用 options 的配置 &#125; Vue.prototype.$toast = (tips,type) =&gt; &#123; if(type)&#123; opt.defaultType = type; // 如果有传type，位置则设为该type &#125; if(document.getElementsByClassName('vue-toast').length)&#123; // 如果toast还在，则不再执行 return; &#125; let toastTpl = Vue.extend(&#123; template: '&lt;div class="vue-toast toast-'+opt.defaultType+'"&gt;' + tips + '&lt;/div&gt;' &#125;); let tpl = new toastTpl().$mount().$el; document.body.appendChild(tpl); setTimeout(function () &#123; document.body.removeChild(tpl); &#125;, opt.duration) &#125; ['bottom', 'center', 'top'].forEach(type =&gt; &#123; Vue.prototype.$toast[type] = (tips) =&gt; &#123; return Vue.prototype.$toast(tips,type) &#125; &#125;)&#125; module.exports = Toast;这样子一个简单的 vue 插件就实现了，并且可以通过 npm 打包发布，下次就可以使用 npm install 来安装了。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2F2017%2F05%2F13%2F%E7%90%86%E8%A7%A3%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[什么是闭包函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内。 – 摘自《JavaScript权威指南》 闭包就是能够读取其他函数内部变量的函数。 闭包可以简单理解成“定义在一个函数内部的函数“。 在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 闭包的用途/优点 可以读取函数内部的变量 让这些变量的值始终保持在内存中，不会在原函数调用后被自动清除 使用闭包的注意点/缺点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 了解JavaScript中的作用域函数作用域12345678910111213function test(o)&#123; var i = 0; if(typeof o == "object")&#123; var j = o; for(var k = 0; k &lt; 10; k++)&#123; console.log(k) &#125; console.log(k) &#125; console.log(j)&#125;test(&#123;a:2&#125;) JavaScript的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。JavaScript函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部。 123456var scope = "global";function f()&#123; console.log(scope); // 输出 “undefined” var scope = "local"; console.log(scope);&#125; 以上代码中第一个输出不是 global，是因为变量提前声明了，它等价于以下代码： 1234567var scope = "global";function f()&#123; var scope; console.log(scope); // 输出 “undefined” scope = "local"; console.log(scope);&#125; 由于JavaScript没有块级作用域，因此将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法似的他们的源代码非常清晰地反映了真实的变量作用域。 实例一123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 类比： 12345678var object = &#123; a:1, b:2, c:3, D:function()&#123; this.c = 4&#125;&#125;var newObject = object; // 这时newObject有了一个作用域，内容和object一样，但指向不一样。newObject.D() // 此时使用一个函数去改变newObject的值，再将newObject打印出来，里面的值已经是改变之后的 以上object好比第一个例子中的f1，当赋值给result的时候，已经有了一个新的作用域，因为result是全局变量，因此不会执行函数之后就被销毁。 实例二利用闭包实现的私有属性存取器方法： 123456789101112131415161718192021function addPrivateProperty(o,name,predicate)&#123; var value ; o['get'+name]=function()&#123; return value; &#125; o['set'+name]=function(v)&#123; if(predicate &amp;&amp; !predicate(v))&#123; throw Error('这是一个错误值'); &#125; else &#123; return value = v; &#125; &#125;&#125;var o = &#123;&#125;;function predicate (v) &#123; return typeof(v) === 'string';&#125;addPrivateProperty(o,'Name',predicate);o.setName("ABIGALE");console.log(o.getName()); 实例三关联到闭包的作用域链都是”活动的”,嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。 123456789function constfuncs() &#123; var funcs = []; for(var i = 0; i &lt; 10; i++)&#123; funcs[i] = function() &#123; return i; &#125; &#125; return funcs;&#125;var funcs = constfuncs();funcs[5](); // 10 实例四1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 实例五12345678function sayAlice() &#123; var sayAlert = function() &#123; console.log(alice); &#125; alice = 'Hello Alice'; return sayAlert;&#125;sayAlice()(); // Hello Alice 如果一个变量没有声明，那它就为全局变量。 123456789var alice = 'Hi Alice';function sayAlice() &#123; var sayAlert = function() &#123; console.log(alice); &#125; alice = 'Hello Alice'; return sayAlert;&#125;sayAlice()(); // Hello Alice 即使在最外层定义了 alice ,但函数内又给它赋值了。 12345678910var alice = 'Hi Alice';function sayAlice() &#123; var sayAlert = function() &#123; console.log(alice); &#125; alice = 'Hello Alice'; return sayAlert;&#125;alice = 'Good MoroningsayAlice()(); // Hello Alice 虽然最后又给 alice 赋值了，但它的执行是在函数 sayAlice 之前，所以我们这里看到它的输出仍然为 Hello Alice。 参考 MDN闭包 学习JavaScript闭包–阮一峰 详解js闭包]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS防御过程]]></title>
    <url>%2F2017%2F05%2F11%2FXSS%E9%98%B2%E5%BE%A1%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[XSS成因是通过利用网页开发时留下的漏洞，通过注入恶意指令代码，使用户加载并执行攻击者恶意制造的网页程序 XSS防御过程： 编码：通过编码解码保护代码 过滤：过滤会破坏我们功能的内容，比如过滤掉用户输入的点击事件，或者iframe(嵌入广告页面) style（可能被用到!important） stript 等节点 校正：被破坏，但没有功能影响 只是DOM错乱之类; 通过构建Node服务和建立一个评论功能，实现XSS的攻击和预防，因为通过评论功能是极其容易被攻击，步骤如下 构造接口 一个编码评论的接口 /comment 一个获取评论的接口 /getComment 123456789router.get('/comment', function (req, res, next) &#123; comments.v = html_encode(req.query.comment);&#125;)router.get('/getComment', function (req, res, next) &#123; res.json(&#123; comment: comments.v &#125;)&#125;) 交互部分，在页面上添加脚本请求接口 页面上添加文本框和按钮 123456&lt;textarea name="name" rows="8" cols="80" id="text"&gt; &lt;p&gt;sks&lt;img src="null" alt="" onerror="alert(1)"&gt;&lt;/p&gt; &lt;/textarea&gt; &lt;button type="button" name="button" id="btn"&gt;评论&lt;/button&gt; &lt;button type="button" name="button" id="get"&gt;获取评论&lt;/button&gt; 添加执行脚本 通过获取页面元素，并对他们添加监听事件 定义一个XMLHttpRequest对象进行前后端数据传输 open函数参数需要请求方法，请求URL 最后发送请求使用send方法 关于编码与解码，我们可以利用第三方库，这部分编码较为复杂 123456789101112131415161718192021222324252627282930313233343536373839//获取元素 var btn = document.getElementById('btn'); var get = document.getElementById('get'); var txt = document.getElementById('text'); //监听评论按钮事件 btn.addEventListener('click', function () &#123; var xhr = new XMLHttpRequest(); var url = '/comment?comment=' + txt.value; xhr.open('GET', url, true); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; console.log(xhr); &#125; else &#123; console.log('error'); &#125; &#125; &#125; xhr.send(); &#125;); //监听获取评论按钮事件 get.addEventListener('click', function () &#123; var xhr = new XMLHttpRequest(); var url = '/getComment'; xhr.open('GET', url, true); xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; var com = parse(JSON.parse(xhr.response).comment); var txt = document.createElement('span'); txt.innerHTML = com; document.body.appendChild(txt); &#125; else &#123; console.log('error'); &#125; &#125; &#125; xhr.send(); &#125;); 利用XSS攻击案例获取cookieXSS 攻击的原理是，攻击者插入一段可执行的 JavaScripts 脚本，该脚本会读出用户浏览器的 cookies 并将它传输给攻击者，攻击者得到用户的 Cookies 后，即可冒充用户。但是要防范 XSS 也很简单，在写入 cookies 时，将 HttpOnly 设置为 true，客户端 JavaScripts 就无法读取该 cookies 的值，就可以有效防范 XSS 攻击。因为 tokens 也是储存在本地的 session storage 或者是客户端的 cookies 中，也是会受到 XSS 攻击。所以在使用 tokens 的时候，必须要考虑过期机制，不然攻击者就可以永久持有受害用户帐号。 Github参考关于 Token，你应该知道的十件事]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件冒泡、事件捕捉和事件委托]]></title>
    <url>%2F2017%2F05%2F11%2F%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%2F</url>
    <content type="text"><![CDATA[如图是事件流的经过， 事件捕获 事件捕获是从外层元素到目标元素的过程，事件冒泡是从目标元素到外层元素的过程 123&lt;div id="wrapper"&gt; &lt;button id="event"&gt;事件处理程序&lt;/button&gt;&lt;/div&gt; 123456789101112131415161718var wrapper = document.getElementById('wrapper');var event = document.getElementById('event');// 理解事件流wrapper.addEventListener('click', function (e) &#123; console.log('捕获阶段执行父元素wrapper的事件处理程序');&#125;, true); // true - 事件句柄在捕获阶段执行wrapper.addEventListener('click', function (e) &#123; console.log('冒泡阶段执行父元素wrapper的事件处理程序');&#125;, false); // false- 默认。事件句柄在冒泡阶段执行event.addEventListener('click', function (e) &#123; console.log('捕获阶段执行子元素event的事件处理程序');&#125;, true);event.addEventListener('click', function (e) &#123; console.log('冒泡阶段执行子元素event的事件处理程序');&#125;, false); 输出结果捕获阶段执行父元素wrapper的事件处理程序捕获阶段执行子元素event的事件处理程序冒泡阶段执行父元素wrapper的事件处理程序冒泡阶段执行子元素event的事件处理程序 阻止冒泡 事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 123&lt;div id="propagation"&gt; &lt;button id="proEvent"&gt;阻止冒泡处理程序&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819// 阻止冒泡var propagation = document.getElementById('propagation');var proEvent = document.getElementById('proEvent');propagation.addEventListener('click', function (e) &#123; console.log('捕获阶段执行父元素propagation的事件处理程序');&#125;, true);propagation.addEventListener('click', function (e) &#123; console.log('冒泡阶段执行父元素propagation的事件处理程序');&#125;, false);proEvent.addEventListener('click', function (e) &#123; console.log('捕获阶段执行子元素proEvent的事件处理程序');&#125;, true);proEvent.addEventListener('click', function (e) &#123; e.stopPropagation(); console.log('冒泡阶段执行子元素proEvent的事件处理程序');&#125;, false); 输出结果捕获阶段执行父元素wrapper的事件处理程序捕获阶段执行子元素event的事件处理程序冒泡阶段执行父元素wrapper的事件处理程序 事件委托 事件委托就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素 1234567&lt;ul&gt; &lt;li&gt;apple&lt;/li&gt; &lt;li&gt;banana&lt;/li&gt; &lt;li&gt;peal&lt;/li&gt; &lt;li&gt;cat&lt;/li&gt; &lt;li&gt;rabbit&lt;/li&gt;&lt;/ul&gt; 12345678910111213// 事件委托var li = document.getElementsByTagName('li');for (var i = 0; i &lt; li.length; i++) &#123; li[i].setAttribute('i', i + 1);&#125;var ul = document.getElementsByTagName('ul')[0];ul.addEventListener('click', function (e) &#123; var target = e.target; if (e.target &amp;&amp; e.target.nodeName.toUpperCase() == 'LI') &#123; var b = e.target.getAttribute('i'); console.log('这是第' + b + '个&lt;li&gt;元素'); &#125;&#125;)]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[构建Node应用，演示反射型XSS攻击]]></title>
    <url>%2F2017%2F05%2F11%2F%E6%9E%84%E5%BB%BANode%E5%BA%94%E7%94%A8%EF%BC%8C%E6%BC%94%E7%A4%BA%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[XSS 全称(Cross Site Scripting) 跨站脚本攻击， 是Web程序中最常见的漏洞。指攻击者在网页中嵌入客户端脚本(例如JavaScript), 当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的. 比如获取用户的Cookie，导航到恶意网站,携带木马等。 步骤： 新建一个文件夹XSS 命令 express -e ./ 初始化一个express项目 npm i下载需要的库 启动服务： 进入XSS，执行命令npm start 原理： 在 index.js 文件中加上 xss字段 123456router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' , xss: req.query.xss &#125;);&#125;); 在 index.ejs 加上如下代码 1&lt;%- xss %&gt; 打开链接 http://localhost:3000/?xss=1 就可以看到传入的xss被显示在页面 攻击方式： 将以上链接改为 http://localhost:3000/?xss=&lt;img src=&quot;null&quot; onerror=&quot;alert(0)&quot;/&gt; 但打开页面的时候发现并没有插入的代码并没有被执行，这是因为浏览器自动做了拦截 取消拦截： 1234567router.get('/', function(req, res, next) &#123; res.set('X-XSS-Protection',0); res.render('index', &#123; title: 'Express' , xss: req.query.xss &#125;);&#125;); 再打开链接时，上述插入的代码也就被执行了。我们可以在xss=图片 页面 等等 参考文档 * [Web安全测试之XSS](http://www.cnblogs.com/TankXiao/archive/2012/03/21/2337194.html)]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[null 和 undefined 的区别]]></title>
    <url>%2F2017%2F05%2F08%2Fnull-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[null是关键字；undefined是Global对象的一个属性 null是对象(空对象, 没有任何属性和方法)；undefined是undefined类型的值。 12document.writeln(typeof null); //return objectdocument.writeln(typeof undefined); //return undefined 对象模型中，所有的对象都是Object或其子类的实例，但null对象例外 document.writeln(null instanceof Object); //return false null“等值(==)”于undefined，但不“全等值(===)”于undefined： 12document.writeln(null == undefined); //return truedocument.writeln(null === undefined); //return false 运算时null与undefined都可以被类型转换为false，但不等值于false： 123document.writeln(!null, !undefined); //return true,truedocument.writeln(null==false); //return falsedocument.writeln(undefined==false); //return false]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式题目]]></title>
    <url>%2F2017%2F05%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[使用编辑器修改内容，在编辑器一般都有全局搜索功能，如使用正则表达式匹配会快速得多，比如下面例子 例子一： 将http下的jpg地址找出来 并去掉http 123456789http:fdsfds/fdsf.jpghttps:fdsfds/fdsf.jpghttp:fdsfds/fdsf.pnghttp:fdsfds/fdsf.pnghttps:fdsfds/fdsf.jpghttp:fdsfds/fdsf.jpghttp:fdsfds/fdsf.pnghttps:fdsfds/fdsf.pnghttp:fdsfds/fdsf.png 答案 http:(.+.jpg) 替换为 $1 解释 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 . 匹配除换行符 \n 之外的任何单字符 匹配前面的子表达式一次或多次 匹配前面的子表达式零次或多次 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。 $1 匹配第一个子表达式 例子二:将时间改为 “XXXX年XX月XX日” 1234562017/02/0525435/04322/053252017-02-23fds/dsa/0512/02/052017-04-05 答案 ^(\d{4})/-/-$ 替换为 $1年$2月$3日 解释 \d 表示数字 {} 标记限定符表达式的开始结束 [] 标记一个中括号表达式的开始 ^ 表示匹配开始的位置 $ 表示匹配结束的位置 例子三：获取一个字符串中的数字字符，并按数组形式输出，如：dgfhfgh254bhku289fgdhdy675gfh，输出[254,289,675] 答案 123var str = 'dgfhfgh254bhku289fgdhdy675gfh';re = \/b+\g;str.match(re); // (3) ["254", "289", "675"] 解释 1234567891011var str = 'dgfhfgh254bhku289fgdhdy675gfh';var re = \/b\;str.match(re); // ["2", index: 7, input: "dgfhfgh254bhku289fgdhdy675"]再继续解决以上问题：全局遍历re = \/b\g;str.match(re); // (9) ["2", "5", "4", "2", "8", "9", "6", "7", "5"]再继续解决以上问题吧：连续出现至少一次以上re = \/b+\g;str.match(re); // (3) ["254", "289", "675"] 例子四：采用replace方法匹配12var req = new ReqExp('\\bis\\b','g')"She is a girl.".replace(req,'IS') // She IS a girl. 解释 g 是全局搜索 i 忽略大小写，默认不忽略大小写。以上例子没体现 字符中之所以用两个反斜杠是为了保留之后的斜杠 1'a1b2c3'.replace(/[abc]/g,'X'); // 'X1X2X3' 将 a 或 b 或 c 替换成X 知识点 ：在括号里 ^ 表示反字符串，也即是非 1'a1b2c3'.replace(/[^abc]/g,'X'); // 'aXbXcX' 将不是 a 或 b 或 c 替换成X 知识点 ：范围类，比如[0-9] [a-z] 1'a1b2c3'.replace(/[a-z]/g,'X'); // 'X1X2X3' 将 a 或 b 或 c 替换成X 获取非abc的 注：如果想要在[]里面匹配 - ，可以[0-9-] 1'2007-01-02'.replace(/[0-9-]/g,'A'); // 'AAAAAAAAAA' 例子五：预定义类1234'@123@abc@'.replace(/@./g,'Q'); // 'Q23Qbc@''@123@abc@'.replace(/^@./g,'Q'); // 'Q23@abc@''@123@abc@'.replace(/.@/g,'Q'); // '@12QabQ''@123@abc@'.replace(/.@$/g,'Q'); // '@123@abQ' 知识点 ：m 表示匹配换行符 123456789var mulStr = "@123@456@789"mulStr.replace(/@./gm,'Q')//Q23//Q56//Q89 例子六：匹配范围尽可能多的匹配-贪婪匹配1'12345678'.replace(/\d&#123;3,6&#125;/,'X'); // 'X78' 例子七：匹配范围尽可能少的匹配-非贪婪匹配1'12345678'.replace(/\d&#123;3,6&#125;?/,'X'); // 'X45678' 例子八：分组匹配12'Abi123Abi4567Abi8'.replace(/Abi&#123;3&#125;/,'X'); // 匹配i连续出现3次'Abi123Abi4567Abi8'.replace(/(Abi)&#123;3&#125;/,'X'); // 用小括号将它分组 匹配Abi连续出现3次 例子九：反向引用，采用 $ 符号1'2015-02-01'.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g,'$2-$3-$1') // '02-01-2015' 例子十：前瞻，断言1'a2*3'.replace(/\w(?=\d)/g,'X'); \\ 'X2*3' 解释：(?=\d)这是断言部分，参与匹配，但不替换 例子十一：RegExp.prototype.test(str)12345678var reg1 = /\w/;var reg2 = /\w/g;reg2.test('ab'); // truereg2.test('ab'); // truereg2.test('ab'); // falsereg2.test('ab'); // truereg2.test('ab'); // true 解释：出现以上结果不一致的原因是因为匹配后再执行一次，会从上一次执行的下一个位置开始。 123456var reg1 = /\w/;var reg2 = /\w/g;while(reg2.test('ab')) &#123; console.log(reg2.lastIndex) // 1 2&#125; 知识点 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回true或false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组或者在未匹配到时返回null。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的String方法。 相关资料 https://juejin.im/entry/58da088fac502e0058e26fb6]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MEAN.js 使用手册]]></title>
    <url>%2F2017%2F04%2F06%2FMEAN-js%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[MEAN.js 是一套开源的 JavaScript 技术栈的 Web 项目解决方案。包含以下内容： 集成 Node.js / Express / MongoDB / Socket.io 的服务器环境 使用 AngularJS 的前端开发 NPM / Bower 包管理 最常用的样例代码，包括用户注册登录、基本增删改查、页面路由等，以及服务端的权限控制 自动化工具（Gulp），包括代码打包、热部署以及发布环境等 按功能模块划分的深度项目结构，自动扫描项目文件 完善的 Log 管理 集成 ESLint 各种发布环境的配置文件，如 Docker 等 总之，基本上我们能想到的项目手脚架需要的东西，它都做好了。 安装环境要求： Node.js 4.x 以上 MongoDB 3.x 以上 Python 2 VC++ 环境 Ruby 安装方法： 使用 Yo Generator 123$ npm install -g yo$ npm install -g generator-meanjs$ yo meanjs 直接拷贝项目目录 https://github.com/meanjs/mean 启动项目首先保证数据库已在默认端口下启动。 下载或生成完成后，cd 到项目目录中，执行 npm install 与 bower install，然后执行 grunt 启动开发服务器。 注意：由于 npm 速度太慢，可以考虑使用镜像 cnpm，参考 https://npm.taobao.org/ 配置说明在项目根目录的 config 文件夹下存放了所有与项目相关的配置文件。其中： assets 的作用是指定项目要往前端页面中加入的 js 与 css 文件，以及要扫描的服务端 js 文件 env 的作用是配置各种运行时的参数，如 Section 过期时间、数据库地址等 lib 下面是项目的主要服务器执行逻辑，如 express 的启动、数据库的连接以及 Model 初始化等 需要注意的是，asserts 与 env 中的配置文件会按照项目的运行环境来进行区分，在加载的时候会有一个合并过程： 读取 default 配置 按照当前运行环境读取环境配置（如 development / production 等） 因此，default 配置中的配置项会被环境配置中的配置项覆盖。我们可以使用这个特性来做很多事情，最简单的比如在不同的环境下连接不同的数据库服务器，而不必更改代码。 除了 default 与环境配置以外，MEAN.js 还提供了 local 配置，用来解决本地开发环境的一些特殊需求，local 配置文件将处于合并的最高级，但它不会被提交到版本控制上面去。 文件结构说明项目的主要业务逻辑被放在了 modules 下面。根据功能模块来划分代码，每个模块下面包括 client 端以及 server 端代码，如下所示： 123456789101112131415161718modules│ └── moduleName| ├── tests //测试文件│ ├── client│ │ ├── config //客户端配置│ │ ├── controllers //angular controller│ │ ├── css //可以使用 CSS 或者 SASS SCSS LESS│ │ ├── img│ │ ├── services //angular service| | ├── directive //angular directive│ │ └── views //HTML 文件│ └── server│ ├── config //服务端配置│ ├── controllers│ ├── models //Mongoose Model│ ├── policies //权限控制模块│ ├── routes //路由拦截│ └── templates //服务端模板 需要注意的是： 文件夹的名字不能写错，不然就扫描不到 注意文件的命名（参考样例文件），便于查找 在 core 模块下存放了一些基础的东西，如 Node.js 用来渲染页面的 ejs 模板，以及基础路由、404 路由等 项目本身已经提供了丰富的基础样例，进行任何业务逻辑的编写都可以直接参考之。 自动化测试测试文件分布在每个 module 下面，同样包括 client 测试与 server 测试。MEAN.js 已经集成了单元测试与 E2E 测试的框架，需要添加测试时，只需按照样例编写相应模块的测试即可。 使用 gulp test 来执行所有测试，同时，如果只想执行某一类型的测试，可以查看 gulpfile 中的具体任务定义。 发布流程项目发布使用 gulp prod，将会启动一个生产环境的服务器。在预配置好的自动化工具中，生产环境与开发环境的区别有： 移除了文件监听与热部署 加入了代码打包 如果我们需要其它环境（如 QA），可以参考 default 与 prod 的配置，自行添加一项 gulp 命令，并在 config 文件夹中添加相应的配置文件即可。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[组件系统技术栈 -- Angular]]></title>
    <url>%2F2017%2F03%2F30%2Fangular%2F</url>
    <content type="text"><![CDATA[Angular组件库文档说明 技术中心前端组-组件系统是采用 AngularJS+Gulp 搭建的项目，该文档主要针对AngularJS如何实现我们的业务代码进行讲解，加深对项目构建的认识，当项目出错时也方便快速定位错误的地方。 Git仓库 Git 目录树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384├── gulp├── gulpfile.js├── package.json├── src│ ├── 404.html│ ├── app│ │ ├── app.js│ │ ├── pages│ │ │ ├── date│ │ │ │ ├── date.js│ │ │ │ └── daterangepicker│ │ │ │ ├── daterangepicker.controller.js│ │ │ │ ├── daterangepicker.html│ │ │ │ └── daterangepicker.module.js│ │ │ ├── input│ │ │ │ ├── input.module.js│ │ │ │ └── select│ │ │ │ ├── select.autoComplete.html│ │ │ │ ├── select.combobox.html│ │ │ │ ├── select.controller.js│ │ │ │ ├── select.filters.js│ │ │ │ ├── select.html│ │ │ │ └── select.module.js│ │ │ ├── pages.module.js│ │ │ ├── progress│ │ │ │ ├── progress.module.js│ │ │ │ └── progressbar│ │ │ │ ├── progressbar.controller.js│ │ │ │ ├── progressbar.html│ │ │ │ └── progressbar.module.js│ │ │ ├── slider│ │ │ │ ├── basic│ │ │ │ │ ├── basic.controller.js│ │ │ │ │ ├── basic.html│ │ │ │ │ └── basic.module.js│ │ │ │ └── slider.module.js│ │ │ ├── table│ │ │ │ ├── basic│ │ │ │ │ ├── basic.controller.js│ │ │ │ │ ├── basic.html│ │ │ │ │ └── basic.module.js│ │ │ │ ├── paging│ │ │ │ │ ├── paging.controller.js│ │ │ │ │ ├── paging.html│ │ │ │ │ └── paging.module.js│ │ │ │ └── table.module.js│ │ │ ├── ui│ │ │ │ ├── basic│ │ │ │ │ ├── basic.controller.js│ │ │ │ │ ├── basic.html│ │ │ │ │ └── basic.module.js│ │ │ │ └── ui.module.js│ │ │ ├── upload│ │ │ │ ├── upload│ │ │ │ │ ├── upload.controller.js│ │ │ │ │ ├── upload.html│ │ │ │ │ └── upload.module.js│ │ │ │ └── upload.module.js│ │ │ ├── validation│ │ │ │ ├── basic│ │ │ │ │ ├── basic.controller.js│ │ │ │ │ ├── basic.html│ │ │ │ │ └── basic.module.js│ │ │ │ └── validation.js│ │ │ └── window│ │ │ ├── modal│ │ │ │ ├── modal.controller.js│ │ │ │ ├── modal.html│ │ │ │ └── modal.module.js│ │ │ ├── tooltip│ │ │ │ ├── tooltip.controller.js│ │ │ │ ├── tooltip.html│ │ │ │ └── tooltip.module.js│ │ │ └── window.module.js│ │ └── theme│ ├── assets│ │ ├── fonts│ │ ├── img│ │ └── pictures│ ├── auth.html│ ├── index.html // 入口页面│ ├── reg.html│ └── sass└── yarn.lock 静态页面index.html1234567&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="BlurAdmin"&gt; // ng-app 指令用于告诉 AngularJS 应用当前这个元素是根元素&lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;div ui-view autoscroll="true" autoscroll-body-top&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 入口文件 app.js 实现与 ng-app 关联起来的模块 BlurAdmin ,BlurAdmin 是一个模块，当启动AngularJS时，就会去匹配这种对应关系，发现一致时则开始执行里面的内容。一个模块可以将其他模块引进来，就如以下 [] 中包含好几个字符串，这些字符串就是一个个module 。 src / app / app.js ： 1234567891011121314151617'use strict';angular.module('BlurAdmin', [ 'ngAnimate', 'ui.bootstrap-slider', '720kb.datepicker', 'daterangepicker', 'ui.bootstrap', 'ui.sortable', 'ui.router', 'ui.select', 'ngTouch', 'toastr', 'hljs', 'BlurAdmin.theme', 'BlurAdmin.pages']); 子模块 我们以其中一个例子为例，比如 daterangepicker 模块，路径为 ‘src / app / pages /data’ 下，这个例子实现日期组件，即系统左侧菜单的“日期组件”。 步骤 新建module BlurAdmin.pages.date (ps:这个module需要注入到BlurAdmin，后面我们将会提到)。 我们会有一级菜单和二级菜单，以下BlurAdmin.pages.date为一级菜单，[]中引进来的module为二级菜单。 src / app / pages / data / date.js ： 12345678910111213141516171819202122(function() &#123;'use strict';angular.module('BlurAdmin.pages.date', ['BlurAdmin.pages.date.daterangepicker']) .config(routeConfig); /** @ngInject */ function routeConfig($stateProvider) &#123; $stateProvider .state('date', &#123; url: '/date', template: '&lt;ui-view autoscroll="true" autoscroll-body-top&gt;&lt;/ui-view&gt;', abstract: true, title: '日期组件', // 菜单名称 sidebarMeta: &#123; icon: 'ion-calendar', // 菜单icon order: 8 // 菜单位置 &#125; &#125;); &#125;&#125;)(); 这时我们已经实现了一级菜单，template中显示的内容为我们引进来的 &#39;BlurAdmin.pages.date.daterangepicker&#39; 即为二级菜单，接下来我们开始实现这个二级菜单。 二级菜单路径为 路径为 ‘src / app / pages / data / daterangepicker’ 以下就是我们刚在 date.js 中引入的module，以下几点解释均以 daterangepicker.module.js 为例 $stateProvider.state(&#39;date.daterangepicker&#39;, {}) 这种写法是因为我们在项目中引入了 Angular-ui-router 当我们在 &lt;a&gt;中加入 ui-sref 属性，如 &lt;a ui-sref=&#39;date.daterangepicker&#39;&gt;&lt;/a&gt; 就会引入 {} 中的的属性。 属性 url : 当执行 &lt;a ui-sref=&#39;date.daterangepicker&#39;&gt;&lt;/a&gt; 时，对应页面的URL为 /daterangepicker ,这就是单页面应用的精髓，它并不会刷新整个页面，只会更新这个module里的内容，其他外层的module不会更新。 属性 templateUrl : 当进入该URL也会有页面上的变化，而这变化的页面路径就指向 templateUrl 里的页面。 属性 controller : 该控制器是实现以上templateUrl页面的数据绑定。 src / app / pages / data / daterangepicker / daterangepicker.module.js ： 12345678910111213141516171819202122(function() &#123; 'use strict'; angular.module('BlurAdmin.pages.date.daterangepicker', []) .config(routeConfig); /** @ngInject */ function routeConfig($stateProvider) &#123; $stateProvider .state('date.daterangepicker', &#123; url: '/daterangepicker', templateUrl: 'app/pages/date/daterangepicker/daterangepicker.html', controller: 'daterangepickerCtrl', controllerAs: 'vm', title: '基础日历', sidebarMeta: &#123; order: 100 &#125; &#125;); &#125;&#125;)(); 子模板引入 我上一标题中我们讲解了module BlurAdmin.pages.date 的实现，这时候我们需要将它引入到我们的入口文件里面。 src / app / pages / pages.module.js ： 123456789101112131415161718192021(function() &#123; 'use strict'; angular.module('BlurAdmin.pages', [ 'ui.router', 'BlurAdmin.pages.ui', 'BlurAdmin.pages.input', 'BlurAdmin.pages.table', 'BlurAdmin.pages.window', 'BlurAdmin.pages.progress', 'BlurAdmin.pages.upload', 'BlurAdmin.pages.date', // 这里!!! 我们以上实现了的module ,引入到一个叫 BlurAdmin.pages 的module里面了。 'BlurAdmin.pages.validation', 'BlurAdmin.pages.slider' ]).config(routeConfig); /** @ngInject */ function routeConfig($urlRouterProvider) &#123; $urlRouterProvider.otherwise('/ui/basic'); &#125;&#125;)(); 我们再看看一开始我们讲解的 app.js src / app / app.js ： 1234567891011121314151617'use strict';angular.module('BlurAdmin', [ 'ngAnimate', 'ui.bootstrap-slider', '720kb.datepicker', 'daterangepicker', 'ui.bootstrap', 'ui.sortable', 'ui.router', 'ui.select', 'ngTouch', 'toastr', 'hljs', 'BlurAdmin.theme', 'BlurAdmin.pages' // 这里!!! 我们又把 BlurAdmin.pages 引进来了]); 结束 ^_^]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件系统技术栈 -- Gulp]]></title>
    <url>%2F2017%2F03%2F29%2F%E7%BB%86%E8%AF%B4gulp%2F</url>
    <content type="text"><![CDATA[Angular组件库文档说明 技术中心前端组-组件系统是采用 AngularJS+Gulp 搭建的项目，该文档主要针对Gulp配置文件主要部分进行说明，加深对项目构建的认识，当项目出错时也方便快速定位错误的地方。 Git仓库 Git 目录树12345678910111213141516171819202122232425262728├── README.md├── bower.json├── gulp // gulp配置文件│ ├── build.js│ ├── conf.js│ ├── devRelease.js│ ├── docs.js│ ├── images.js│ ├── inject.js│ ├── marketplace.js│ ├── scripts.js│ ├── server.js│ ├── styles.js│ └── watch.js├── gulpfile.js // gulp配置文件入口├── package.json└── src // 业务代码 ├── 404.html ├── app │ └── theme ├── assets │ ├── fonts │ ├── img │ └── pictures ├── auth.html ├── index.html ├── reg.html └── sass gulp gulp 用于前端项目的构建，如监控程序文件变化，检查js代码正确性，压缩js，源码转换到发布目录，启动web 服务测试等等 命令：gulp 执行任务顺序123456789101112131415├── clean // 执行之前先清空之前打包后的文件└── build // 打包任务 ├── html // html打包 │ ├── inject │ │ ├── scripts │ │ ├── styles │ │ ├── injectAuth │ │ │ └── stylesAuth │ │ ├── inject404 │ │ │ └── styles404 │ │ └── copyVendorImages │ └── partials ├── fonts // 字体打包 └── other // 其他文件打包，如图片 └── copyVendorImages 入口文件 gulpfile.js gulp 的使用从 gulpfile.js 开始，先看看该项目 gulpfile.js 的内容 1234567891011121314&apos;use strict&apos;;var gulp = require(&apos;gulp&apos;);var wrench = require(&apos;wrench&apos;);wrench.readdirSyncRecursive(&apos;./gulp&apos;).filter(function(file) &#123; return (/\.(js|coffee)$/i).test(file);&#125;).map(function(file) &#123; require(&apos;./gulp/&apos; + file);&#125;);gulp.task(&apos;default&apos;, [&apos;clean&apos;], function () &#123; gulp.start(&apos;build&apos;);&#125;); 这段代码引入了 wrench , 先解释下wrench是做什么的 wrench 这是NodeJS中递归进行文件操作，即递归指定文件夹下的文件，我们递归了 &#39;./gulp&#39; 文件夹下以 js|coffee 为后缀的文件如何一一引进来。 路径文件 为了代码的优雅程度，也为了让我们有清晰的思路，我们建立这个文件用来存放路径，之后用到只需要写路径对应的变量即可。 gulp / conf.js 123456789101112131415161718192021222324var gutil = require('gulp-util');exports.paths = &#123; src: 'src', dist: 'release', devDist: 'dev-release', tmp: '.tmp', e2e: 'e2e'&#125;;exports.wiredep = &#123; exclude: [/\/bootstrap\.js$/, /\/bootstrap-sass\/.*\.js/, /\/require\.js/], directory: 'bower_components', overrides: &#123;&#125;&#125;;exports.errorHandler = function (title) &#123; 'use strict'; return function (err) &#123; gutil.log(gutil.colors.red('[' + title + ']'), err.toString()); this.emit('end'); &#125;;&#125;; task : clean gulp-load-plugins 提供一个便捷方式，我们只需要将需要的功能方法引进来就可以调用它，这里我们使用了del方法，引入 conf.js，然后情况该路径下的文件或文件夹。 1234567891011var path = require('path');var gulp = require('gulp');var conf = require('./conf');var $ = require('gulp-load-plugins')(&#123; pattern: ['gulp-*', 'main-bower-files', 'uglify-save-license', 'del']&#125;);gulp.task('clean', function () &#123; return $.del([path.join(conf.paths.dist, '/'), path.join(conf.paths.tmp, '/')]);&#125;); task : build 该任务完成了html,font 的打包 html打包 该任务执行的是遍历文件夹找到html文件，进行压缩打包后，放入指定文件夹内 12345678910111213141516gulp.task('html',function () &#123; var htmlFilter = $.filter('*.html', &#123; restore: true, dot:true&#125;); //遍历找到对应的html文件 return gulp.src(path.join(conf.paths.tmp, '/serve/*.html')) .pipe(htmlFilter) .pipe($.minifyHtml(&#123; empty: true, spare: true, quotes: true, conditionals: true &#125;)) .pipe(htmlFilter.restore) .pipe(gulp.dest(path.join(conf.paths.dist, '/'))) .pipe($.size(&#123; title: path.join(conf.paths.dist, '/'), showFiles: true &#125;)); &#125;); font 打包方法同上12345gulp.task('fonts', function () &#123; return gulp.src($.mainBowerFiles('**/*.&#123;eot,svg,ttf,woff,woff2&#125;')) .pipe($.flatten()) .pipe(gulp.dest(path.join(conf.paths.dist, '/fonts/')));&#125;); task : watch 这部分是为了实时监控代码的更新变化，当新增加一类文件时，发现页面没有效果，可以看看是否将路径或文件类型加到这部分里面。 123456789101112131415161718192021222324gulp.watch([path.join(conf.paths.src, '/*.html'), 'bower.json'], ['inject-reload']); gulp.watch([ path.join(conf.paths.src, '/sass/**/*.css'), path.join(conf.paths.src, '/sass/**/*.scss') ], function(event) &#123; if(isOnlyChange(event)) &#123; gulp.start('styles-reload'); &#125; else &#123; gulp.start('inject-reload'); &#125; &#125;); gulp.watch(path.join(conf.paths.src, '/app/**/*.js'), function(event) &#123; if(isOnlyChange(event)) &#123; gulp.start('scripts-reload'); &#125; else &#123; gulp.start('inject-reload'); &#125; &#125;); gulp.watch(path.join(conf.paths.src, '/app/**/*.html'), function(event) &#123; browserSync.reload(event.path); &#125;); task : serve serve 是启动项目所用，当执行 gulp serve 时，会执行 watch 任务后打开对应路径下的静态页面。 123gulp.task('serve', ['watch'], function () &#123; browserSyncInit([path.join(conf.paths.tmp, '/serve'), conf.paths.src]);&#125;);]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Angular-Gulp项目]]></title>
    <url>%2F2017%2F03%2F28%2F%E6%90%AD%E5%BB%BAAngular-Gulp%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[项目简介 该项目是一个 angular + gulp 搭建起来的简易框架。 Angular 是一组用来开发 Web 页面的框架、模板以及数据绑定和丰富 UI 组件。它支持整个开发进程，提供 Web 应用的架构，无需进行手工 DOM 操作。 AngularJS 很小，只有 60K，兼容主流浏览器。 Gulp 是一个自动化构建工具，通过代码优于配置的策略，它可以让简单的任务简单，复杂的任务更可管理；通过流式操作，减少频繁的 IO 操作，更快地构建项目。 项目目录12345678910├── app│ ├── app.js│ └── index.html├── build│ ├── index.html│ └── js│ └── app.js├── gulpfile.js├── package.json└── readme.md 初始化项目在命令面板敲下npm init 初始化项目并生成 package.json 。 新建项目 mkdir angular-gulp 切换进入 cd angular-gulp 初始项目 npm init 安装框架 npm install angular --save-dev ( 如已安装yarn，可直接执行yarn add angular ) 建立静态文件 新建文件夹 angular-gulp/src 静态页面 index.html angular-gulp / src / index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="app"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Dome&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="AppCtrl as vm"&gt; &lt;h1 class="title"&gt;Hello&lt;/h1&gt; &lt;a ng-href="&#123;&#123;vm.url&#125;&#125;" target="_blank"&gt;Welcome to Abigale's Blog&lt;/a&gt; &lt;/div&gt; &lt;script src="./js/app.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 脚本 app.js angular-gulp / src / app.js 12345678910class AppCtrl &#123; constructor() &#123; this.url = 'https://abigaleypc.github.io'; &#125;&#125;var AppModule = angular.module('app', []) .controller('AppCtrl', AppCtrl);module.exports = AppModule; 这时候直接打开index.html，页面中url若可正常点击进入，则这一步成功了，接下来我们将在项目中使用gulp。 开始gulp 安装gulp npm install --save-dev gulp 在根目录下新建 gulpfile.js angular-gulp / gulpfile.js 123456var gulp = require('gulp'); gulp.task('default', function() &#123; // 将你的默认的任务代码放在这 console.log("gulp start")&#125;); 这时候在命令面板上执行 gulp ，将会打印出 “ gulp start ” task : 清空文件夹 gulp可用来压缩代码，将代码放置一个文件夹内，当我们将代码放于该文件夹之前，先清空它，避免堆积的无用文件越来越多 npm install --save-dev rimraf angular-gulp / gulpfile.js 12345const rimraf = require('rimraf');gulp.task('clean', cb =&gt; &#123; rimraf('./build', cb);&#125;); 在build文件夹下新增任意文件或文件夹，当执行命令 gulp clean 时，build之下的文件或文件夹将会被清空 task : 打包代码 新建一个任务 build ，该任务是将文件夹 app 中代码压缩放于 build 文件夹之下 npm install --save-dev rimraf gulp-babel gulp-sourcemaps gulp-less gulp-uglify gulp-htmlmin brower-sync angular-gulp/gulpfile.js 1234567891011121314151617181920212223242526272829303132333435const rimraf = require('rimraf');const babel = require('gulp-babel');const sourcemaps = require('gulp-sourcemaps');const less = require('gulp-less');const uglify = require('gulp-uglify');const htmlmin = require('gulp-htmlmin');const browserSync = require('browser-sync').create();// html 代码压缩gulp.task('htmlmin', () =&gt; &#123; gulp.src('./app/index.html') // 找到指定路径下的html .pipe(htmlmin(&#123; collapseWhitespace: true // 压缩 &#125;)) .pipe(gulp.dest('./build')); // 将压缩后的代码放到build文件夹下&#125;);// js 代码压缩gulp.task('script', () =&gt; &#123; gulp.src(['./app/*.js', './app/**/*.js']) .pipe(babel(&#123; presets: ['es2015', 'stage-0'] &#125;)) // .pipe(uglify()) // 生产模式 .pipe(sourcemaps.write('.')) // 开发模式 .pipe(gulp.dest('./build/js')) .pipe(browserSync.stream());&#125;);//样式 代码压缩gulp.task('style', () =&gt; &#123; gulp.src(['./app/*.less', './app/**/*.less']) .pipe(less()) .pipe(gulp.dest('./build/css')) .pipe(browserSync.stream());&#125;); task : 检测代码并实时更新angular-gulp / gulpfile.js 12345gulp.task('watch', () =&gt; &#123; gulp.watch(['./app/index.html'], ['htmlmin']); // 实时检测html 当该文件发生变化时，就执行 task:htmlmin gulp.watch(['./app/**/*.js'], ['script']); gulp.watch(['./app/**/*.less'], ['style']);&#125;); task : 启动服务器angular-gulp / gulpfile.js 123456789gulp.task('serve', () =&gt; &#123; browserSync.init(&#123; server: &#123; baseDir: '.' &#125; &#125;); gulp.watch(['./app/index.html']).on('change', browserSync.reload);&#125;); gulpfile.js 总结以上的 gulpfile.js 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const gulp = require('gulp');const rimraf = require('rimraf');const babel = require('gulp-babel');const sourcemaps = require('gulp-sourcemaps');const less = require('gulp-less');const uglify = require('gulp-uglify');const htmlmin = require('gulp-htmlmin');const browserSync = require('browser-sync').create();gulp.task('clean', cb =&gt; &#123; rimraf('./build', cb);&#125;);gulp.task('htmlmin', () =&gt; &#123; gulp.src('./app/index.html') .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(gulp.dest('./build'));&#125;);gulp.task('script', () =&gt; &#123; gulp.src(['./app/*.js', './app/**/*.js']) .pipe(babel(&#123; presets: ['es2015', 'stage-0'] &#125;)) // .pipe(uglify()) // 生产模式 .pipe(sourcemaps.write('.')) // 开发模式 .pipe(gulp.dest('./build/js')) .pipe(browserSync.stream());&#125;);gulp.task('style', () =&gt; &#123; gulp.src(['./app/*.less', './app/**/*.less']) .pipe(less()) .pipe(gulp.dest('./build/css')) .pipe(browserSync.stream());&#125;);gulp.task('serve', () =&gt; &#123; browserSync.init(&#123; server: &#123; baseDir: '.' &#125; &#125;); gulp.watch(['./app/index.html']).on('change', browserSync.reload);&#125;);gulp.task('watch', () =&gt; &#123; gulp.watch(['./app/index.html'], ['htmlmin']); gulp.watch(['./app/**/*.js'], ['script']); gulp.watch(['./app/**/*.less'], ['style']);&#125;); gulp.task('default', ['clean', 'style', 'script', 'htmlmin', 'serve'], () =&gt; &#123; gulp.start('watch');&#125;); 启动项目执行命令 gulp , 并切换到 build 路径下]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>angular</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Angular-Webpack项目]]></title>
    <url>%2F2017%2F03%2F23%2F%E6%90%AD%E5%BB%BAAngular-Webpack%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Demo项目目录12345678├── dist // 打包后生成的静态文件│ ├── app.js│ └── index.html├── package.json // 项目配置文件├── src // 项目源文件│ ├── app.js│ └── index.html└── webpack.config 初始化项目在命令面板敲下npm init 初始化项目并生成 package.json 。 新建项目 mkdir angular-webpack 切换进入 cd angular-webpack 初始项目 npm init 安装框架 npm install angular --save-dev ( 如已安装yarn，可直接执行yarn add angular ) 入口文件 新建src文件夹，存放业务代码。在src下新建index.html入口文件。 src / index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en" ng-app="app"&gt; // 指定当前这个元素是根元素。&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Dome&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-controller="AppCtrl as vm"&gt; // 为应用添加控制器 &lt;h1 class="title"&gt;Hello&lt;/h1&gt; &lt;a ng-href="&#123;&#123;vm.url&#125;&#125;" target="_blank"&gt;Welcome to Abigale's Blog&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 新建app.js文件，与index.html实现双向绑定。 src / app.js 123456789101112const angular = require('angular')class AppCtrl &#123; constructor() &#123; this.url = 'https://abigaleypc.github.io'; &#125;&#125;var AppModule = angular.module('app', []) .controller('AppCtrl', AppCtrl);module.exports = AppModule; 添加Webpack模块 安装模块 npm install webpack --save-dev 编写配置文件 新建配置文件夹 webpack.config,在该文件夹之下新建base.js webpack.config / base.js 1234567891011121314151617181920212223242526272829const path = require(&apos;path&apos;)const root = path.resolve(__dirname, &apos;..&apos;) // 项目的根目录绝对路径module.exports = &#123; entry: path.join(root, &apos;src/app.js&apos;), // 入口文件路径 output: &#123; path: path.join(root, &apos;dist&apos;), // 出口目录 filename: &apos;app.js&apos; // 出口文件名 &#125;, resolve: &#123; alias: &#123; // 配置目录别名 // 在任意目录下require(&apos;components/example&apos;) 相当于require(&apos;项目根目录/src/components/example&apos;) components: path.join(root, &apos;src/components&apos;), views: path.join(root, &apos;src/views&apos;), styles: path.join(root, &apos;src/styles&apos;), store: path.join(root, &apos;src/store&apos;) &#125;, extensions: [&apos;&apos;, &apos;.js&apos;], // 引用js和vue文件可以省略后缀名 fallback: [path.join(root, &apos;node_modules&apos;)] // 找不到的模块会尝试在这个数组的目录里面再寻找 &#125;, resolveLoader: &#123; fallback: [path.join(root, &apos;node_modules&apos;)] // 找不到的loader模块会尝试在这个数组的目录里面再寻找 &#125;, module: &#123; // 配置loader loaders: [ &#123; test: /\.js$/, loader: &apos;babel&apos;, exclude: /node_modules/ &#125; // .js文件使用babel-loader，切记排除node_modules目录 ] &#125;&#125; webpack.config / dev.js 12345678910111213141516171819202122232425262728const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)const merge = require(&apos;webpack-merge&apos;)const baseConfig = require(&apos;./base&apos;)const root = path.resolve(__dirname, &apos;..&apos;) // 项目的根目录绝对路径const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)module.exports = merge(baseConfig, &#123; devServer: &#123; historyApiFallback: true, // 404的页面会自动跳转到/页面 inline: true, // 文件改变自动刷新页面 progress: true, // 显示编译进度 colors: true, // 使用颜色输出 port: 3000, // 服务器端口 &#125;, devtool: &apos;source-map&apos;, // 用于标记编译后的文件与编译前的文件对应位置，便于调试 entry: [ &apos;webpack/hot/dev-server&apos;, // 热替换处理入口文件 path.join(root, &apos;src/app.js&apos;) ], plugins: [ new webpack.HotModuleReplacementPlugin(), // 添加热替换插件,每次改动文件不会再整个页面都刷新 new HtmlWebpackPlugin(&#123; template: path.join(root, &apos;src/index.html&apos;), // 模板文件 inject: &apos;body&apos; // js的script注入到body底部, 使用HtmlWebpackPlugin，实现js入口文件自动注入 &#125;) ]&#125;) webpack.config / pro.js 123456789101112131415const path = require(&apos;path&apos;)const webpack = require(&apos;webpack&apos;)const merge = require(&apos;webpack-merge&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const baseConfig = require(&apos;./base&apos;)const root = path.resolve(__dirname, &apos;..&apos;)module.exports = merge(baseConfig, &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(root, &apos;src/index.html&apos;), // 模板文件 inject: &apos;body&apos; // js的script注入到body底部 &#125;) ]&#125;) 执行命令在项目 package.json 中添加如下命令 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.config/dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.config/pro.js&quot; &#125; 打开命令面板 执行 npm run dev ，打开浏览器 http://localhost:3000/。 执行 npm run build，生成 dist下静态文件。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>WebpackJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其]]></title>
    <url>%2F2017%2F03%2F16%2Fqi%2F</url>
    <content type="text"><![CDATA[其的温文儒雅总感染着我，午后的阳光似乎因为那温柔的语气变得安谧了好些许，我不知道怎么形容才是最恰当的，我只是想听听这种声音，你身上那动人的故事，像是空气里的棉絮飞舞着，你真是个美好的姑娘，失恋了还那么美，你过得不好，你失落却在转眼间笑出了泪花，你说从没这么疯狂地做过这种事情，我想人总要在某个低谷觉得自己一无所有才会豁出去，你有很多顿悟，我希望我可以尽可能理解你，还好我们承认人每时每刻想法都可能变，过去成誓死捍卫的东西，好像一夜之间也会被自己毁尸灭迹，我们还会变成曾经认为很傻很讨厌的人，我不反对你，同样你支持我的所有想法，取舍总在一念之间，一份淡然的心态包容世间万物。讲起我的故事，你同样也会拥于怀抱，我真庆幸身边有这样的伙伴，知己，不止你，还有很多的你，我讲过千千万万遍我是个幸运的女孩，我也感谢那些低谷，经过一番洗礼的我总如重生一般，让我更加小心翼翼拿捏自己，还有我所有的。想起胡导跟我讲过，其实没有什么是注定是自己的，连自己都不是。确实我们总要离开，一眼似乎也可以望到头，但一点也不悲观，胡导跟我讲的时候那嬉笑的样子我还记得，我变得不那么害怕，回头看自己也变成了小大人，那些教诲要听，是好是坏，走的这一路我会用标尺去衡量。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css 学习]]></title>
    <url>%2F2017%2F03%2F09%2Fcss-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[字体不换行，超出加省略号123white-space: nowrap; // 文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止overflow: hidden;text-overflow: ellipsis; 画三角形12345width:0;height:0;border-width:6px;border-style:solid dashed dashed dashed;border-color:#bb0909 transparent transparent transparent; 反选字体颜色背景看微博时发现全选后字体背景是橙色的 1234567891011/* Mozilla based browsers */::-moz-selection &#123; background-color: #FFA; color: #000;&#125;/* Works in Safari */::selection &#123; background-color: #FFA; color: #000;&#125;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript学习]]></title>
    <url>%2F2017%2F03%2F09%2FjavaScript%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[判断对象是否包含某属性自身实例&amp;原型链 存在于自身实例和原型链上的，均返回 true, 否则返回 false instanceof in Object.prototype.isPrototypeOf(XXXX) 自身实例 只有来自自身对象，返回true，否则返回false hasOwnProperty 获取实例对象所有属性 Object.getOwnPropertyNames(XXXX.prototype) 可参考《javascript高级程序设计》第六章 try catch throw try 语句允许我们定义在执行时进行错误测试的代码块 catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。 throw 创建自定义错误 1234567function message() &#123; try &#123; noFun("123"); //这是一个不存在的函数 &#125; catch (err) &#123; alert('本页面有有个错误：' + err.message); &#125;&#125; 自定义错误抛出例子： 12345678910function message() &#123; var y = document.getElementById('in').value; try &#123; if (y == 3) throw '值不能等于3'; if (isNaN(y)) throw '应为数字'; if (y &gt; 10) throw '值不能大于10'; &#125; catch (err) &#123; alert(err); //与上面例子不一样，这里不需要加message &#125;&#125; js验证 以下是表单验证例子，将验证内容包含在标签form里面。 123456789101112131415161718192021222324252627282930313233343536&lt;html&gt;&lt;head&gt; &lt;script&gt; function validate_email(field, alerttxt) &#123; with(field) &#123; apos = value.indexOf('@'); dotpos = value.lastIndexOf('.') if (apos &lt; 1 || dotpos - apos &lt; 2) &#123; alerr(alerttxt); return false; &#125; else &#123; return true; &#125; &#125; &#125; function validate_form(thisform) &#123; with(thisform) &#123; if (thisform) &#123; if (validate_email(email, "Not a valid e-mail address!") == false) &#123; email.focus(); return false; &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;from action="submitpage.html" onsubmit="return validate_form(this);" method="post"&gt; Email:&lt;input type="text" name="email" size="30"&gt; &lt;input type="submit" value="Submit"&gt; &lt;/from&gt;&lt;/body&gt;&lt;/html&gt; with 语句用于设置代码在特定对象中的作用域。可参考 关于arguments类型 非数组，不从 Array.prototype 继承。有属性 length, 但无其他数组有的属性，如 splice, concats 等 非对象 类数组对象：要让它使用数组的方法，可以用 call 或者 apply 的方法改变 this 去执行。 1234567891011121314function SecicalArray() &#123; typeof arguments; // object Object.prototype.toString.call(arguments) // [object Arguments]&#125;// 造一个类数组对象var foo = &#123; 0: 'Java', 1: 'Python', 2: 'Scala', length: 3&#125;console.log( Array.prototype.slice.call(foo)) // [ 'Java', 'Python', 'Scala' ] JavaScript 创建对象的七种方式。 工厂模式 构造函数模式 原型模式 构造函数和原型组合模式 动态原型模式 寄生构造模式 稳妥构造模式 JavaScript 继承 接口继承：只继承方法签名 实现继承：继承实际方法]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS的组成：ECMAScript、BOM和DOM]]></title>
    <url>%2F2017%2F03%2F09%2FJS%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9AECMAScript%E3%80%81BOM%E5%92%8CDOM%2F</url>
    <content type="text"><![CDATA[Javascript由三部分组成： ECMAScript:javaScript的核心 DOM:规定了访问HTML和XML的接口 BOM:提供了独立于内容而在浏览器窗口之间进行交互的对象和方法 ECMAScript这部分不属于浏览器，它可以定义变量，函数等 ECMAScript这部分不属于浏览器，它可以定义变量，函数等 DOM全称:Document Object Model , 文档对象模型 DOM定义了操作HTML的接口，比如写了一个html文档，浏览器根据DOM元素渲染成树形结构 BOM全称:Browser Object Model , 浏览器对象模型 BOM 定义了 JavaScript 操作浏览器的接口，提供了访问某些功能（如浏览器窗口大小、版本信息、浏览历史记录等）的途径以及操作方法。]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js判断屏幕大小]]></title>
    <url>%2F2017%2F03%2F09%2Fjs%E5%88%A4%E6%96%AD%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[js代码：12345678let screenWidth = document.body.clientWidth;if (screenWidth &lt; 768) &#123;&#125;if (screenWidth &gt;= 768 &amp;&amp; screenWidt &lt; 992) &#123;&#125;if (screenWidth &gt;= 992) &#123;&#125;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[项目总结]]></title>
    <url>%2F2017%2F03%2F09%2F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[清晰项目脉络 (不写重复性代码，可复用则复用) 读懂需求，分析需求 (如文案见解，提出自己建议) 不照搬代码，而要理解原理（如$reslove 和 $http） 建立属于自己的库，分多类：js， angular 文档整齐整理，不复制，多自己手写 清晰项目脉络 (不写重复性代码，可复用则复用)]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XMLHttpRequest 学习]]></title>
    <url>%2F2017%2F02%2F26%2FXMLHttpRequest-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[XHR介绍 XMLHttpRequest 对象用于在后台与服务器交换数据。 可以在chrome console输入以下代码 1234var url = 'https://abigaleypc.github.io/';var xmlhttp=new XMLHttpRequest(); //创建 XMLHttpRequest 对象xmlhttp.open("GET",url,true); //open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。xmlhttp.send(null); //Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 访问xmlhttp可以看到以下结果： 12345678910XMLHttpRequest：&#123; onabort : null, onerror : null, readyState : 4, response : '……', responseText : '……', status : 200, statusText :'OK' ……&#125; 属性 readyState HTTP 请求的状态.当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。5 个状态中每一个都有一个相关联的非正式的名称，下表列出了状态、名称和含义： 状态 名称 描述 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。 2 Sent Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。 4 Loaded HTTP 响应已经完全接收。 readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了 abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 onreadystatechange 事件句柄。 responseText 目前为止为服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。 responseXML 对请求的响应，解析为 XML 并作为 Document 对象返回。 status 由服务器返回的 HTTP 状态代码,这类状态代码表明服务器成功地接受了客户端请求。 200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 - Created 服务器已经创建了文档，Location头给出了它的URL。 202 - Accepted 已经接受请求，但处理尚未完成。 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（HTTP 1.1新）。 204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 - Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 详细参考:XMLHTTPRequest状态status完整列表 statusText 这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status 属性一样，当 readyState 小于 3 的时候读取这一属性会导致一个异常。 Angular-resource angular附带了两种请求办法：$http 和 $rescource 安装ngResource模块是一个可选的angularjs模块，如果需要使用，我们要单独引用js 1&lt;script type="text/javascript" src="/javascripts/angular-resource.js"&gt; 应用$resource 我们并不是直接通过$resource服务本身同服务器通信，$resource是一个创建资源对象的工厂，用来创建同服务端交互的对象。 1var User = $resource('/api/users/:userId', &#123;userId:'@id'&#125;); 返回的User对象包含了同后端服务进行交互的方法，我们可以把User对象理解成同RESTFul的后端服务进行交互的接口。该对象包含两个get类型的方法已经三个非get类型的方法。 用法 解释 User.get({id:’123’}, successFn, errorFn) 该方法向url发送一个get请求，并期望一个json类型的响应。这里会向/api/users/123发送一个请求，successFn处理请求成功响应，errorFn处理错误。 User.query(params, successFn, errorFn) 同get()方法使用类似，一般用来请求多条数据。 save(params, payload, successFn, errorFn) save方法会发起一个post请求，params参数用来填充url中变量，对象payload会作为请求体进行发送 delete(params, payload, successFn,errorFn) delete方法一个DELETE请求，payload作为消息体进行发送 remove(params, payload, successFn, errorFn) 同delete类似，不同的是remove用来移除多条数据 通过$resource生成的对象来同服务器进行交互的时候，我们看可以定义处理成功以及处理失败的函数，这些函数接受的参数不仅仅是简单的对象，而是经过包装之后的对象，会被添加$save(), $remove(), $delete三个方法，可以直接调用这三个方法来后服务端进行交互。 1234User.get(&#123;id:'123'&#125;, function(user)&#123; user.name = 'changeAnotherName'; user.$save(); //这里等价于User.save(&#123;id:'123'&#125;,&#123;name:'changeAnotherName'&#125;)&#125;); 扩展$resource$resource对常见的五种请求进行封装，我们还可以对$resource进行扩展。这里要扩展$resource我们需要传入第三个参数，该参数是一个对象。 1234567891011121314$resource('/api/users',&#123;&#125;,&#123; sendEmail:&#123; method:'', url:'', params:&#123;&#125;, isArray:boolean, transformRequest:函数或者函数数组 transformResponse:函数或者函数数组 cache:布尔型或缓存对象 timeout:数值或promise对象 withCredentials:布尔类型 responseType:字符串，用来设置XMLHttpRequestResponseType属性 &#125;&#125;) 我们也可以将$resource服务当做自定义服务的基础。 123angular.module('testApp', ['ngResource']),factory('UserService',['$resource', function($resource)&#123; return $resource(url,&#123;&#125;,&#123;&#125;);&#125;]); 这种方法很常用，例如 Server中： 1234567891011export default angular .module('app.services', []) .factory('libraryService', libraryService);libraryService.$inject = ['$resource']function libraryService($resource) &#123; getLibraryTags: function() &#123; return $resource('/apis/auth/tags').query(); &#125;&#125; Controller中：(需要注意的是：该controller引入以上server时需要是同个module或者引入该module) 1libraryService.getLibraryTags() 如果想用.then().then()链式写法，可改下Serives添加promise： 1234567891011121314151617export default angular .module('app.services', []) .factory('libraryService', libraryService);libraryService.$inject = ['$resource']function libraryService($resource) &#123; return &#123; getBookInfo: function(currentPage, itemsPerPage, sortBy) &#123; return $resource('/apis/auth/new').save(&#123; currentPage: currentPage, itemsPerPage: itemsPerPage, sortBy: sortBy &#125;).$promise; // 添加promise &#125; &#125;&#125; Controller中： 123libraryService.getNewBookList(vm.currentPage, vm.itemsPerPage, vm.sortBy).then(function(data) &#123; //使用then() vm.bookList = data;&#125;);]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular $location]]></title>
    <url>%2F2017%2F02%2F15%2Fangular-location%2F</url>
    <content type="text"><![CDATA[$location服务解析地址栏中的URL（基于window.location），让你在应用代码中能获取到。改变地址栏中的URL会反应$location服务中，反之亦然。 $location服务: 暴露当前地址栏的URL，这样你就能 获取并监听URL。 改变URL。 当出现以下情况时同步URL 改变地址栏 点击了后退按钮（或者点击了历史链接） 点击了一个链接 一系列方法来获取URL对象的具体内容用（protocol, host, port, path, search, hash）.formatDate window.location $location.service 目的 允许对当前浏览器位置的读写 同左 API 暴露一个“裸聊”的能被读写的对象 暴露jquery风格的读写器 是否在AngularJS应用生命周期中和应用整合 否 可获取到应用声明周期内的每一个阶段，并且和$watch整合 是否和HTML5 API的无缝整合 否 是（对低级浏览器优雅降级） 和应用的上下文是否相关 否，window.location.path返回”/docroot/actual/path” 是，$location.path()返回”/actual/path”]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery判断滚动条是否到达窗口顶部和底部]]></title>
    <url>%2F2017%2F02%2F14%2FJquery%E5%88%A4%E6%96%AD%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%98%AF%E5%90%A6%E5%88%B0%E8%BE%BE%E7%AA%97%E5%8F%A3%E9%A1%B6%E9%83%A8%E5%92%8C%E5%BA%95%E9%83%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; alert($(window).height()); //浏览器时下窗口可视区域高度 alert($(document).height()); //浏览器时下窗口文档的高度 alert($(document.body).height());//浏览器时下窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器时下窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器时下窗口可视区域宽度 alert($(document).width());//浏览器时下窗口文档对于象宽度 alert($(document.body).width());//浏览器时下窗口文档body的高度 alert($(document.body).outerWidth(true));//浏览器时下窗口文档body的总宽度 包括border padding margin``` &lt;!--more--&gt;```javascript var win_height=$(window).height(); var doc_height=$(document).height(); var scroll_top=$(document).scrollTop(); /* doc_height是文档的高度，scroll_top是滚动条上部离文档顶部的高度，window_height表示窗口高度。 当scroll_top == 0 时，表示滚动条已经到达窗口顶部。 当scroll_top + window_height &gt;= doc_height 时，表示滚动条已经到达窗口底部。 */ //判断滚动条是否到达窗口底部 $(window).bind('scroll', function()&#123; //绑定滚动事件 if($(document).scrollTop() + $(window).height() &gt;= $(document).height())&#123; console.log(win_height); console.log($(document).scrollTop()); console.log(doc_height); //...... &#125; &#125;); &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document属性和方法]]></title>
    <url>%2F2016%2F12%2F10%2F%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2URL%2F</url>
    <content type="text"><![CDATA[Document 对象每个载入浏览器的 HTML 文档都会成为 Document 对象。Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263document.title //设置文档标题等价于HTML的title标签document.bgColor //设置页面背景色document.fgColor //设置前景色(文本颜色)document.linkColor //未点击过的链接颜色document.alinkColor //激活链接(焦点在此链接上)的颜色document.vlinkColor //已点击过的链接颜色document.URL //设置URL属性从而在同一窗口打开另一网页document.fileCreatedDate //文件建立日期，只读属性document.fileModifiedDate //文件修改日期，只读属性document.charset //设置字符集 简体中文:gb2312document.fileSize //文件大小，只读属性document.cookie //设置和读出cookie———————————————————————常用对象方法document.write() //动态向页面写入内容document.createElement(Tag) //创建一个html标签对象document.getElementById(ID) //获得指定ID值的对象document.getElementsByName(Name) //获得指定Name值的对象document.body.appendChild(oTag)———————————————————————body-主体子对象document.body //指定文档主体的开始和结束等价于body&gt;/body&gt;document.body.bgColor //设置或获取对象后面的背景颜色document.body.link //未点击过的链接颜色document.body.alink //激活链接(焦点在此链接上)的颜色document.body.vlink //已点击过的链接颜色document.body.text //文本色document.body.innerText //设置&lt;body&gt;…/body&gt;之间的文本document.body.innerHTML //设置&lt;body&gt;…/body&gt;之间的HTML代码document.body.topMargin //页面上边距document.body.leftMargin //页面左边距document.body.rightMargin //页面右边距document.body.bottomMargin //页面下边距document.body.background //背景图片document.body.appendChild(oTag) //动态生成一个HTML对象常用对象事件document.body.onclick=”func()” //鼠标指针单击对象是触发document.body.onmouseover=”func()” //鼠标指针移到对象时触发document.body.onmouseout=”func()” //鼠标指针移出对象时触发———————————————————————location-位置子对象document.location.hash // #号后的部分document.location.host // 域名+端口号//好像返回的是主机名localhost,没有返回端口号document.location.hostname // 域名document.location.href // 完整URLdocument.location.pathname // 目录部分document.location.port // 端口号document.location.protocol // 网络协议(http:)document.location.search // ?号后的部分documeny.location.reload() //刷新网页document.location.reload(URL) //打开新的网页document.location.assign(URL) //打开新的网页document.location.replace(URL) //打开新的网页———————————————————————selection-选区子对象document.selection]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular中dialog参数传递]]></title>
    <url>%2F2016%2F12%2F07%2FAngular%E4%B8%ADdialog%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[Angular的官方文档 解决方案一按照官方文档，在html中加入点击事件弹出对话框 1234//html&lt;md-button class="md-primary md-raised" ng-click="showAdvanced($event)" &gt; Alert Dialog&lt;/md-button&gt; 12345678910111213141516171819202122232425262728293031//js$scope.showAdvanced = function(ev) &#123; $mdDialog.show(&#123; controller: DialogController, //又一个controller templateUrl: 'temp.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose:true, fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints. &#125;) .then(function(answer) &#123; $scope.status = 'You said the information was "' + answer + '".'; &#125;, function() &#123; $scope.status = 'You cancelled the dialog.'; &#125;); &#125;; function DialogController($scope, $mdDialog) &#123; $scope.hide = function() &#123; $mdDialog.hide(); &#125;; $scope.cancel = function() &#123; $mdDialog.cancel(); &#125;; $scope.answer = function(answer) &#123; //一开始我并没有理解好这里的。$mdDialog.hide(answer);会返回一个值，就是answer，需要在对话框的模板（html）传入进来。 $mdDialog.hide(answer); &#125;; &#125; 将对话框的内容与原本页面的内容进行通话：可以在$mdDialog.show中添加local参数，这个参数将原controller中的数据传至对话框，就如上面的例子 1234567891011121314151617181920$scope.showAdvanced = function(ev) &#123; $mdDialog.show(&#123; controller: DialogController, //又一个controller templateUrl: 'temp.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose:true, fullscreen: $scope.customFullscreen， // Only for -xs, -sm breakpoints. //添加一下参数用于传递 locals:&#123; items : $scope.items &#125; &#125;) .then(function(answer) &#123; $scope.status = 'You said the information was "' + answer + '".'; &#125;, function() &#123; $scope.status = 'You cancelled the dialog.'; &#125;); &#125;; 接着就可以在对话框的controller找到items了,将它放在controller里的参数传进来 123456789101112131415function DialogController($scope, $mdDialog ,items ) &#123; $scope.hide = function() &#123; $mdDialog.hide(); &#125;; $scope.cancel = function() &#123; $mdDialog.cancel(); &#125;; $scope.answer = function(answer) &#123; console.log(items)//这样就输出成功了 items = 改变的值 //可以这么改变item $mdDialog.hide(answer); &#125;;&#125; 解决方案二这种方式是添加的controller用原先的controller。这样就可以使用外层的controller了12345678910111213141516171819202122232425262728vm.newBooking = function()&#123; vm.bookingliveInfo = &#123; 'codingLanguageList':vm.createCodingLanguageList[0], 'projectType':vm.createProjectTypeList[0], 'grade':vm.createGreade[0], 'liveTime':moment().format('YYYY-MM-DD HH:mm:ss') &#125; $mdDialog.show(&#123; controller: function () &#123; return vm; &#125;, controllerAs: 'vm', clickOutsideToClose: false, preserveScope: true, templateUrl: temp.html' &#125;);&#125;vm.createSchedule = function()&#123; ScheduleService.addBooking(vm.bookingliveInfo).then(function success(result)&#123; toastr.success(result.msg); $mdDialog.hide(); vm.getScheduleInfo(); vm.bookingliveInfo = null; &#125;,function error(error)&#123; toastr.error(error); &#125;)&#125;]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个人的朝圣]]></title>
    <url>%2F2016%2F07%2F29%2F%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%9C%A3%E6%9C%9D%2F</url>
    <content type="text"><![CDATA[朝圣是宗教或灵性生活寻觅灵性意义的过程，通常是到一处圣地或者是对某人信仰有重要意义的地方。各大宗教都有朝圣的活动。从世俗的角度而言，朝圣是一种族群的认同，而非基于信仰。流行文化也正把朝圣重新定义，例如去探访某小说、电视剧、电影或ACG等作品取材、拍摄的地点也被称为朝圣、圣地巡礼。旅游业兴起之前，朝圣是人们离开家乡出外游历的主要方式之一。一个人的朝圣原来要理解为一个人的信仰，书中最讽刺的一段是很多人纷纷加入行走的队列，有的人负责讲解。“黑猩猩”负责记录，吃加工过的食物就会被谴责，因为这不是朝圣者的初衷，朝圣者是徒步，就像野外生存一样，那时候的哈罗德形象才变得高大吧，只是在我这个千百万读者之中的我这么认为，不装腔作势，他多想变成回到一个人的时候，一个人走，而没那么多形式主义，这个社会就是这样，最最原始，原汁原味的东西都在加工，装饰，结果一个恶心的味道还要让很多人去感受社会多美好，这个世上也就是有这两种人，两种人都在宣传价值观，正确的三观，一种是羊，一种是披着羊皮的狼，哈罗德用很纯净很天然的想法，去诠释自己的一份小小信念。也许是看了书中大家解读着朝圣者应当如何，丑化了这个字眼，让我更想用一个人的信仰还说说这个书。乔伊斯·蕾秋，一个英国资深作家，我想内容真诚才会写出真诚的文字，人性本善，不要被社会磨去最最可贵的东西。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范工具 -- eslint]]></title>
    <url>%2F2013%2F04%2F06%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7-eslint%2F</url>
    <content type="text"><![CDATA[安装 在根目录下运行命令 npm install eslint -g 本例中使用eslint进行js代码检验，需引入 gulp-eslint，执行命令 npm install gulp-eslint 在es6环境下使用gulp-eslint，还需要安装 babel-eslint，npm install babel-eslint 使用方法 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）对项目进行配置 .eslintrc 放在项目根目录，则会应用到整个项目；如果子目录中也包含 .eslintrc 文件，则子目录会忽略根目录的配置文件，应用该目录中的配置文件。这样可以方便地对不同环境的代码应用不同的规则。 .eslintrc 文件示例： 1234567891011121314151617181920212223242526272829303132333435&#123; "parser": "babel-eslint", "env": &#123; "browser": true, "node": true, "es6": true, "jquery": true, "jasmine": true &#125;, "extends": "standard", "globals": &#123; "angular": false, "$": false, "_": false, "Handlebars": false, "moment": false, "alasql": false, "inject": false, "getJSONFixture": false &#125;, "rules": &#123; "semi": [ 2, "always" ], "space-before-function-paren": [ 2, &#123; "anonymous": "always", "named": "never", "asyncArrow": "always" &#125; ] &#125;&#125; 在 gulp 中添加 eslint 代码校验任务 task 代码块示例： 12345678var eslint = require('gulp-eslint');gulp.task('eslint',function()&#123; return gulp.src(['src/app/pages/**/*.js','src/app/pages/*.js']) //指定的校验路径 .pipe(eslint(&#123;configFle:"./.eslintrc"&#125;)) //使用你的eslint校验文件 .pipe(eslint.format()) .pipe(eslint.failAfterError());&#125;); 为 eslint 添加实时监听： 123gulp.task('serve', ['eslint','watch'], function () &#123; browserSyncInit([path.join(conf.paths.tmp, '/serve'), conf.paths.src]);&#125;); 启动 在命令面板中执行 gulp eslint 运行结果若代码做有不规范的地方，则会出现如以下的报错：]]></content>
      <categories>
        <category>Front-End</category>
      </categories>
      <tags>
        <tag>ESLint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安逸时光]]></title>
    <url>%2F2011%2F06%2F22%2F%E5%AE%89%E9%80%B8%E6%97%B6%E5%85%89%2F</url>
    <content type="text"><![CDATA[又一个五天结束了，不算假期，却让自己有了放假的心情。今天中考的学生看上去都没有一副终于释放的样子，跟两年前的自己好像，但忍不住替他们开心，丽嘲笑我说爽的又不是我，穷开心什么呢。冰心说成功的花，人们只惊羡她现时的明艳！当初它的芽儿，浸透了奋斗的泪泉我就是忽视了它。包括自己，本身缺少的那份拼搏，没有多少资本去评论什么。 这两天都窝在图书馆，并不是多安静的环境，却让我悄悄爱上了它，电视上网络上看过的图书馆，总会让自己心生好多幻想曲，现代化的建筑，一层不染的地板，静逸的环境被一些年轻人，一个两个稀稀疏疏有味地啃着书籍的氛围渲染着，而我看到的图书馆，被雨水侵袭后在粉白的墙上留下不雅观的黑色，长出小植物，玻璃退成暗黄色，桌子旧得让顽固的木材脱落，在这里男女老少皆有，有的学习看书，而有些听歌聊天，一些老一辈甚至把电话开扬声不顾旁人眼光大声接电话，与图书馆这名词多不称，然而这里却有一股气息，让人看到时光，看到时间怎样一分一秒可以从眼前告诉你要走了，于是因为岁月，你便懂得要珍惜，因为一切都是褪了色，让你不得不小心翼翼珍爱它，在这里的分分秒秒。在这里可以看到各色各样的人，偶尔会去猜想这些人这些事，然后放在心里让自己抬脚走下一步，这里没什么特别，却能在无声无息中给我莫大的力量，我想久久年后，如果它还在，像那些白发人一样，我会习惯性拿起右手边的报刊，在慢慢喝一口白开水，扶起老花镜，一字一字咬读最近时事。]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
</search>
